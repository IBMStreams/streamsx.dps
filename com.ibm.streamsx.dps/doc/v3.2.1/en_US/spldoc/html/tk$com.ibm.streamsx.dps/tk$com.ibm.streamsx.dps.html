<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="Toolkit com.ibm.streamsx.dps 3.2.1"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_toolkit"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>Toolkit com.ibm.streamsx.dps 3.2.1</title>
</head>
<body id="spldoc_toolkit">


<h1 class="title topictitle1 spltoolkitname">Toolkit <tt class="ph tt">com.ibm.streamsx.dps 3.2.1</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">Streams DPS Toolkit</a> &gt; com.ibm.streamsx.dps 3.2.1</p>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">General Information</h2>


<div class="p">The Distributed Process Store (DPS) toolkit enables multiple applications running processing elements (PEs) on one or more machines to share application specific state information.  The shared information is stored in an external data store. This allows non-fused SPL, C++ and Java operators running on different machines to share information.  The following external data stores are supported:
<ul class="ul">
<li class="li"> RedisÂ® versions 2.8.2+, 3.0.x and 3.2.x.</li>

</ul>
The toolkit consists of a set of native functions that provide access to shared state, and additional locking functionality to provide safe, concurrent access to the shared data. These functions can be used from anywhere inside a Streams application, whether it be SPL code, SPL functions, SPL native functions, C++ primitive operators.  They also have counterparts written in Java that can be used from a Java primitive operator. The actual state information is stored separately in the distributed back-end in-memory store which is transparent to the Streams application. 
</div>

</div>

<div class="section"><h2 class="title sectiontitle">Conceptual Overview
</h2>

<p class="p">The following diagram provides a conceptual overview of the interaction between the Streams application, the DPS toolkit, and the  distributed back-end in-memory store. Each green box represents a processing element (PE) of the application. These interconnected PEs have access to the DPS logical container as well as full access to the data store APIs.  In the logical view layer, code abstraction is done to communicate with the back-end in-memory store. Any PE, regardless of whether it originally created the store and populated it with its original contents (if any), can safely access the store (shown in the physical view layer) to save and retrieve contents. To access the store, the PE requires a valid store name or a store handle. 
</p>

<p class="p"><br/><img class="image" src="../../image/copy/1$overview.png" alt=""/><br/>
</p>

<p class="p">As shown in the figure above, an instance of the DPS accommodates one or more user-created stores.  Each store can hold an unlimited number of data items stored as key-value pairs created using any SPL type as a key and any SPL type as a value. Additionally, a DPS instance contains a store factory that can manufacture stores on demand. Similarly, any store can be accessed concurrently by any number of PEs running on different machines.  In order to ensure safe access (i.e. store operations do not override each other), each DPS instance contains a lock factory enabling you to create shareable locks for the purpose of locking a store during a critical private operation and then releasing the lock once that critical store operation has completed.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Notes for supported data stores
</h2>

<div class="p">
<ul class="ul">
<li class="li"> Redis 2.8.x: If you have a heavy workload of put/get requests, then using multiple Redis servers  may give scaling to improve the overall throughput. You can manually configure and start multiple instances of Redis to listen and run on different ports and/or machines.  The DPS toolkit will internally treat these Redis v2.8.x multiple instances as multiple shards and distribute the key-value pairs among those instances to improve performance with increased memory capacity. If you have multiple Redis servers configured, consider using the DPS Time To Live (TTL) APIs, discussed below. This will result in better scalability of your put/get requests than using the APIs that take the user created store id as a function argument. Choose the APIs according to your functional and scaling needs. </li>

<li class="li"> Redis 3.0.x or 3.2.x: If you choose to use these versions to take advantage of the Redis built-in high availability and clustering, fail-over, replication and persistence features, it is important to note that, those new Redis 3.x features may impact the overall performance of reading from and writing data to the Redis cluster nodes.</li>

<li class="li"> Redis 3.2.x servers are by default configured to block connections from remote machines and remote IP addresses other than the loopback (127.0.0.1) address. See the comments in the <tt class="ph tt">redis.conf</tt> configuration file for more information. This restriction means that if Streams is running on a machine different from the Redis server, you will need to reconfigure and restart the Redis server to accept remote connections.  Make the following changes in your redis configuration file:
<ul class="ul">
<li class="li"> Comment out the line <tt class="ph tt">bind 127.0.0.1</tt></li>

<li class="li"> Make sure <tt class="ph tt">protected-mode</tt> is set to <tt class="ph tt">no</tt>.   </li>

<li class="li"> Restart Redis, making sure to specify the path to the modified configuration file.</li>

</ul>
</li>

</ul>

</div>

</div>

<div class="section"><h2 class="title sectiontitle">Toolkit overview
</h2>

<p class="p">The functions provided by the DPS toolkit are divided into 3 categories:
</p>

<div class="p">
<ul class="ul">
<li class="li"> User created data stores, </li>

<li class="li"> TTL global store, in which  pairs can be configured to expire after a certain time period,</li>

<li class="li"> Distributed lock API</li>

</ul>
Note: The toolkit provides the aforementioned functionality as native functions that can be used from C++ and SPL applications and  through a fully object oriented Java API.  The comments below apply regardless of the programming language being used.  
</div>

</div>

<div class="section"><h2 class="title sectiontitle">User Created Stores
</h2>

<p class="p">A DPS store is a container in which  pairs can be created, retrieved from, updated and deleted. The keys and values must be a SPL primitive type, such as <tt class="ph tt">rstring</tt> or <tt class="ph tt">int32</tt>, or a SPL composite type such as a <tt class="ph tt">map</tt>.  You can perform Create, Read, Update, Delete (CRUD) operations simultaneously on numerous stores that you own, share, and manage within the context of one or more Streams applications. You can create your own stores and share application-specific data across multiple Streams processing elements (PEs) and across multiple Streams applications running on one or more machines. The key-value pairs are kept inside each individual user-created stores. Applications can create and use many such user specified stores at the same time. There is also support for running arbitrary one-way data store commands from within your application. See the <tt class="ph tt">dpsRunDataStoreCommand()</tt> functions. The core functions needed to manage the lifecycle of a DPS store in a SPL application are in the com.ibm.streamsx.store.distributed namespace. These functions allow you to perform operations such as create/get/remove stores, put/get/check key value pairs, iterate over the store, serialize/deserialize stores.  
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Time to Live (TTL) Store
</h2>

<p class="p">The toolkit also provides a set of functions for storing key-value pairs that are configured to expire after a certain time period.   When the pre-assigned TTL value expires, these data items will be automatically removed from the data store.  Key Value pairs stored and obtained using these functions will not belong to any user created stores. Instead, they will be stored at the top level global area of the configured Redis back-end. When applications have a need to put data items with a TTL value and get them back, you can use these functions without having to create individual stores.  These functions all have a "TTL" suffix. These ephemeral key value pairs can only be used with the aforementioned functions and cannot be used with  any functions that take store name or store id as a function argument.
</p>

<p class="p">A non-zero TTL value passed to these functions will automatically remove the key-value pairs at the end of their specified lifetime. A TTL value of zero will keep the key-value pair in the back-end data store forever or until such time as they are removed manually using the <tt class="ph tt">dpsRemoveTTL()</tt> function.
</p>

<p class="p">These functions will return true or false indicating whether the operation succeeded or not. In the case of a false return value, an error code and an error string can be obtained.  In the Redis back-end data store, TTL based data items can coexist with other user created stores containing data items that could live forever.  Such TTL based APIs only provide a limited set of functions (put, get, has, and remove), but at the same time will have a slightly lower overhead than the feature rich non-TTL based functions.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Distributed Locking API
</h2>

<p class="p">The DPS Toolkit also provides the following distributed locking functions which can be used for accessing stores from multiple threads and multiple processes safely without overriding each other.  This is achieved using a trust based cooperative locking scheme to gain exclusive access into the stores for performing a set of transaction based store activities.
</p>

  <dl class="dl"><dt class="dt dlterm"><a class="xref" href="tk$com.ibm.streamsx.dps$1.html">Developing and running applications that use the DPS Toolkit</a>
</dt>
<dd class="dd">
</dd>
</dl>

<dl class="dl">
  
  <dt class="dt dlterm">Version</dt>

  <dd class="dd">3.2.1</dd>

  
  
  <dt class="dt dlterm">Required Product Version</dt>

  <dd class="dd">4.0.0.0</dd>

  
</dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Indexes</h2>
  
  <dl class="dl">
    <dt class="dt dlterm"/>
<dd class="dd"/>

    <dt class="dt dlterm"><a class="xref" href="ix$Namespace.html">Namespaces</a></dt>
<dd class="dd"/>

    <dt class="dt dlterm"><a class="xref" href="ix$Operator.html">Operators</a></dt>
<dd class="dd"/>

    <dt class="dt dlterm"><a class="xref" href="ix$Function.html">Functions</a></dt>
<dd class="dd"/>

  </dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Namespaces</h2>
  
  <dl class="dl">
    
      <dt class="dt dlterm splpart"><a class="xref" href="ns$com.ibm.streamsx.lock.distributed.html">com.ibm.streamsx.lock.distributed</a></dt>

      <dd class="dd"/>

      <dd class="dd"><dl class="dl">
        <dt class="dt dlterm">Functions</dt>

        <dd class="dd">
<ul class="sl simple">
<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlAcquireLock.uint64.float64.float64.uint64">dlAcquireLock(uint64, float64, float64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlAcquireLock.uint64.uint64">dlAcquireLock(uint64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlCreateOrGetLock.rstring.uint64">dlCreateOrGetLock(rstring, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlGetLastDistributedLockErrorCode">dlGetLastDistributedLockErrorCode()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlGetLastDistributedLockErrorString">dlGetLastDistributedLockErrorString()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlGetPidForLock.rstring.uint64">dlGetPidForLock(rstring, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlReleaseLock.uint64.uint64">dlReleaseLock(uint64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.lock.distributed.html#spldoc_functions__dlRemoveLock.uint64.uint64">dlRemoveLock(uint64, uint64)</a></li>

</ul>

        </dd>

      </dl>
</dd>

         
      <dt class="dt dlterm splpart"><a class="xref" href="ns$com.ibm.streamsx.store.distributed.html">com.ibm.streamsx.store.distributed</a></dt>

      <dd class="dd"/>

      <dd class="dd"><dl class="dl">
        <dt class="dt dlterm">Operators</dt>

        <dd class="dd">
<ul class="sl simple">
<li class="sli"><a class="xref" href="op$com.ibm.streamsx.store.distributed$DPSAux.html">DPSAux</a></li>

<li class="sli"><a class="xref" href="spl$com.ibm.streamsx.store.distributed$DpsGetTTLWithReconnect.html#spldoc_compilationunit__composite_operator__DpsGetTTLWithReconnect">DpsGetTTLWithReconnect</a></li>

<li class="sli"><a class="xref" href="spl$com.ibm.streamsx.store.distributed$DpsPutTTLWithReconnect.html#spldoc_compilationunit__composite_operator__DpsPutTTLWithReconnect">DpsPutTTLWithReconnect</a></li>

</ul>

        </dd>

      </dl>
</dd>

      <dd class="dd"><dl class="dl">
        <dt class="dt dlterm">Functions</dt>

        <dd class="dd">
<ul class="sl simple">
<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsBase64Decode.rstring.rstring">dpsBase64Decode(rstring, rstring)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsBase64Encode.rstring.rstring">dpsBase64Encode(rstring, rstring)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsBeginIteration.uint64.uint64">dpsBeginIteration(uint64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsClear.uint64.uint64">dpsClear(uint64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsCreateOrGetStore.rstring.T1.T2.uint64">dpsCreateOrGetStore(rstring, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsCreateStore.rstring.T1.T2.uint64">dpsCreateStore(rstring, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsDeserialize.uint64.blob.T1.T2.uint64">dpsDeserialize(uint64, blob, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsEndIteration.uint64.uint64.uint64">dpsEndIteration(uint64, uint64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsFindStore.rstring.uint64">dpsFindStore(rstring, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGet.uint64.T1.T2.uint64">dpsGet(uint64, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetDetailsAboutThisMachine.rstring.rstring.rstring">dpsGetDetailsAboutThisMachine(rstring, rstring, rstring)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetLastErrorCodeTTL">dpsGetLastErrorCodeTTL()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetLastErrorStringTTL">dpsGetLastErrorStringTTL()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetLastStoreErrorCode">dpsGetLastStoreErrorCode()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetLastStoreErrorString">dpsGetLastStoreErrorString()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetNext.uint64.uint64.T1.T2.uint64">dpsGetNext(uint64, uint64, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetNoSqlDbProductName">dpsGetNoSqlDbProductName()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetSafe.uint64.T1.T2.uint64">dpsGetSafe(uint64, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetSplTypeNameForKey.uint64">dpsGetSplTypeNameForKey(uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetSplTypeNameForValue.uint64">dpsGetSplTypeNameForValue(uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetStoreName.uint64">dpsGetStoreName(uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetTTL.T1.T2.uint64">dpsGetTTL(T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsGetTTL.T1.T2.uint64.boolean.boolean">dpsGetTTL(T1, T2, uint64, boolean, boolean)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsHas.uint64.T1.uint64">dpsHas(uint64, T1, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsHasTTL.T1.uint64">dpsHasTTL(T1, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsHasTTL.T1.uint64.boolean">dpsHasTTL(T1, uint64, boolean)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsIsConnected">dpsIsConnected()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsPersist.uint64">dpsPersist(uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsPut.uint64.T1.T2.uint64">dpsPut(uint64, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsPutSafe.uint64.T1.T2.uint64">dpsPutSafe(uint64, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsPutTTL.T1.T2.uint32.uint64">dpsPutTTL(T1, T2, uint32, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsPutTTL.T1.T2.uint32.uint64.boolean.boolean">dpsPutTTL(T1, T2, uint32, uint64, boolean, boolean)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsPutTTL.T1.T2.uint32.uint64.uint32.uint32.boolean.boolean">dpsPutTTL(T1, T2, uint32, uint64, uint32, uint32, boolean, boolean)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsReconnect">dpsReconnect()</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsRemove.uint64.T1.uint64">dpsRemove(uint64, T1, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsRemoveStore.uint64.uint64">dpsRemoveStore(uint64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsRemoveTTL.T1.uint64">dpsRemoveTTL(T1, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsRemoveTTL.T1.uint64.boolean">dpsRemoveTTL(T1, uint64, boolean)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsRunDataStoreCommand.list:.:rstring:.:.rstring.uint64">dpsRunDataStoreCommand(list&lt;rstring&gt;, rstring, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsRunDataStoreCommand.rstring.uint64">dpsRunDataStoreCommand(rstring, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsRunDataStoreCommand.uint32.rstring.rstring.rstring.rstring.rstring.rstring.uint64">dpsRunDataStoreCommand(uint32, rstring, rstring, rstring, rstring, rstring, rstring, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsSerialize.uint64.blob.T1.T2.uint64">dpsSerialize(uint64, blob, T1, T2, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsSetConfigFile.rstring">dpsSetConfigFile(rstring)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__dpsSize.uint64.uint64">dpsSize(uint64, uint64)</a></li>

<li class="sli"><a class="xref" href="fc$com.ibm.streamsx.store.distributed.html#spldoc_functions__initializeDpsNoException">initializeDpsNoException()</a></li>

</ul>

        </dd>

      </dl>
</dd>

       </dl>

</div>

</div>


</body>
</html>