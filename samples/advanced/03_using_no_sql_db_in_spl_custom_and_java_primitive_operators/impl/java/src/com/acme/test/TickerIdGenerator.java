/* Generated by Streams Studio: September 23, 2013 11:35:48 PM EDT */
/*
==========================================================================================================  
Main purpose of this Java primitive operator is to explain how to use the dps (Distributed Process Store).
The dps functions are all written in C++. That means, we will have to use JNI to dip into those C++ dps
functions from any Java primitive operator's code.

In order to use the dps functions in your own Java primitive operators, you can use this example as a
reference and adopt similar things done here.

1) You have to import the dpsHelper package as done below. This helper package is part of 
   the dps toolkit ($STREAMS_INSTALL/toolkits/com.ibm.streamsx.dps/impl/java/lib/dps-helper.jar). This jar file contains the
   Java dps APIs that the Java primitive operator developers will use. We added that jar file
   to the java build path of the 062_XXXX SPL project. We specifically did that inside the 
   properties of this 062_XXXXX SPL project.
   
   a) You can right click at the top-level 062_XXXXXX project name and select "Properties". In the resulting
   dialog, select "Java Build Path" in the left pane. Now, on the right pane, select the "Libraries" tab.
   There, you may see the dps-helper.jar file. If that full path is either missing or pointing to  a different
   location on your machine, you should remove that existing entry and "Add an External Jar" by
   navigating to your specific $STREAMS_INSTALL/toolkits/com.ibm.streamsx.dps/impl/java/lib directory.

   In addition, you must also do the following:

   This Java primitive operator class is extended from a Streams AbstractOperator and
   in addition it uses a lot of other Streams Java artifacts such as the Tuple class. In order to
   resolve those Streams Java classes and compile it correctly, you have to do the following.
 
      i)   Ensure you are in the Streams Studio.
      ii)  Right click on the 062_XXXXX project and select Properties.
      iii) In the left pane of the resulting dialog, click on "Java Build Path".
      iv)  In the right pane, click on the tab titled "Libraries".
      v)   Click the "Add External Jars" button, add the following Streams jar files from your
           Streams installation directory.
       
           <Your Streams Install Directory>/lib/com.ibm.streams.operator.jar
           <Your Streams Install Directory>/lib/com.ibm.streams.operator.samples.jar
           <Your Streams Install Directory>/ext/lib/commons-math-2.1.jar
                
   b) After adding these three dependent jar files, you may delete/remove the three
      erroneous jar entries in your "Libraries" tab that point to invalid directories.
      
   c) Now, right-click on the 062_XXXXX project and select "Build Active Configurations".

2) Please refer to the <library> sections in the operator model XML file for this Java primitive operator.
   You will notice that there are two of them each with its own libPath element.
   
   a) First <library> section contains a libPath element that points to the 
      impl/java/bin which is part of this project directory. That is where the
      compiled class file for this primitive operator java code is stored.
      
   b) Second <library> section contains a libPath element that points to the 
      the dps-helper.jar file. This typically should point to the jar file inside the
      dps toolkit directory: $STREAMS_INSTALL/toolkits/com.ibm.streamsx.dps/impl/java/lib/dps-helper.jar

3) Since we have to go through a convoluted path of JNI to access the dps functions from Java code,
   it is recommended that you carefully study the nuances of how it is done below.
   This code is documented to a decent extent for helping the developers who are new to the dps toolkit.
   This Java primitive operator example is very comprehensive and gives a good coverage for all the dps APIs.
   You may simply do a case insensitive search for "store" and then follow along the code in this file. 
   
CAUTION
-------
If you are planning to run this Java primitive operator with a memcached or Couchbase back-end server,
you should be aware of the fact that memcached and Couchbase put a limit on the length of the key.
Test case 23 below will attempt to store a key:value pair with a key length exceeding that
allowed limit (240 characters). You will get an exception for test case 23 and 24 while running this
example with memcached or Couchbase. In the case of memcached and Couchbase, please comment out the entire code block for
test cases #23 and #24.

You can happily run all the test cases in this Java primitive operator with other supported K/V stores.
Because, those other K/V stores don't have such a limitation. They allow keys with a size of few kilobytes.
==========================================================================================================  
*/
package com.acme.test;

// Import the dps and dl packages. If you want to use the dps and dl APIs for
// the store and the distributed locking operations inside your Java primitive operator,
// then these two imports must be done. 
import com.ibm.streamsx.dps.*;
import com.ibm.streamsx.dl.*;
import org.apache.log4j.Logger;

import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.TimeUnit;
import java.io.InputStream;
import java.math.*;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
// import java.nio.ByteBuffer;

import org.apache.commons.math.complex.Complex;
import org.apache.commons.math.complex.ComplexFormat;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.ibm.streams.operator.model.SharedLoader;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.types.*;

/**
 * Class for an operator that receives a tuple and then optionally submits a tuple. 
 * This pattern supports a number of input streams and a single output stream. 
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>process() handles a tuple arriving on an input port 
 * <li>processPuncuation() handles a punctuation mark arriving on an input port 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
@PrimitiveOperator(name="TickerIdGenerator", namespace="com.acme.test",
description="Java Operator TickerIdGenerator")
@InputPorts({@InputPortSet(description="Port that ingests tuples", cardinality=1, optional=false, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious), @InputPortSet(description="Optional input ports", optional=true, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious)})
@OutputPorts({@OutputPortSet(description="Port that produces tuples", cardinality=1, optional=false, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating), @OutputPortSet(description="Optional output ports", optional=true, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating)})
//Add the DPS toolkit's Java library (dps-helper.jar) to the path of this operator.
//There are 2 ways to do this:
//1. If your application will have access to the Streams install location at runtime, then you can specify the full path to the location of the dps-helper.jar file present inside the DPS toolkit as follows:
@Libraries("@STREAMS_INSTALL@/toolkits/com.ibm.streamsx.dps/impl/java/lib/dps-helper.jar")
//if that path will be accessible at runtime. 
//2. Or, you can copy the dps-helper.jar from <STREAMS_INTSALL>/toolkits/com.ibm.streamsx.dps/impl/java/lib/dps-helper.jar into the lib folder of this application and reference it as follows:
//@Libraries("lib/dps-helper.jar")

// Add the following annotation if you are going to fuse this Java operator with other Java operators that will also use
// the DPS APIs. In that case, it is necessary to add the following annotation so that the fused PE will use a shared class loader.
// This annotation is typically effective only when all the fused Java operators have exactly the 
// same entries in their @Libraries annotation (That rule is from Java and not from Streams). 
// If you don't have this annotation, it will give a runtime exception by trying to load the DPS .so library multiple times 
// from within a single fused PE.
//
// Exception in thread "Thread-17" java.lang.UnsatisfiedLinkError: /homes/hny5/sen/workspace27/062_data_sharing_between_non_fused_spl_custom_and_java_primitive_operators/output/com.acme.test.Main/Standalone/../../../../com.ibm.streamsx.dps/impl/java/bin/../../lib/x86_64.RHEL6/libDpsJavaLibLoader.so (Library is already loaded in another ClassLoader)
// at java.lang.ClassLoader.loadLibraryWithPath(ClassLoader.java:1217)
//
// If you can't use a shared class loader in your project for other technical reasons, then remove the following annotation line and search for 
// "FusedCondition" inside the DpsHelper.java (in the DPS toolkit impl/java/src directory). Read the commentary there to make
// the necessary code changes in that file for having fused Java operators access the DPS APIs. Then, rebuild the dps-helper.jar file
// to have a workaround for the fused Java operators' access of the DPS within their processing logic.
//
@SharedLoader(true)
public class TickerIdGenerator extends AbstractOperator {
	// Declare a member variable to hold the instance of the dps store factory object.
	private StoreFactory sf = null;
	// Declare a member variable to hold the instance of the distributed lock factory object.
	private LockFactory lf = null;
	
    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO:
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation, 
        // or external configuration files or a combination of the two.
        
        // We must first call this initialize method before using any other API from the DPS toolkit.
        // We have a choice to either use the default DPS config file inside this application directory (etc/no-sql-kv-store-servers.cfg)  
        // or a DPS config file available from a different directory (/tmp/my-dps-config-file.cfg) outside of this application's directory structure.
        // 1) In the case of using the default DPS config file, we can  simply call initialize().
        // 2) In the case of using a different DPS file located elsewhere, we can call initialize("/mydir/somefile.txt").
     	DistributedStores.initialize();
        // DistributedStores.initialize("/tmp/my-dps-config.txt");
        
        // We have to get a store factory for creating/getting/finding/removing stores throughout the lifetime of this Java primitive operator.
        sf = DistributedStores.getStoreFactory();
        // We have to get a lock factory for creating/acquiring/releasing/removing distributed locks as needed inside this Java primitive operator.
        lf = DistributedLocks.getLockFactory();        
	}

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
    	// This method is commonly used by source operators. 
    	// Operators that process incoming tuples generally do not need this notification. 
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    }

    /**
     * Process an incoming tuple that arrived on the specified port.
     * <P>
     * Copy the incoming tuple to a new output tuple and submit to the output port. 
     * </P>
     * @param inputStream Port the tuple is arriving on.
     * @param tuple Object representing the incoming tuple.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public final void process(StreamingInput<Tuple> inputStream, Tuple tuple)
            throws Exception {

    	// Create a new tuple for output port 0
        StreamingOutput<OutputTuple> outStream = getOutput(0);
        OutputTuple outTuple = outStream.newTuple();

        // Copy across all matching attributes.
        outTuple.assign(tuple);

        // In this Java primitive operator, we will execute two different code blocks.
        // 1) At first, We will exercise several of the dps APIs and learn about the
        //    way in which they have to be invoked and then learn how to receive the
        //    results coming from those dps APIs.
        //
        // 2) After learning about the dps APIs to a great extent, we will process the
        //    incoming tuple sent by an upstream operator and perform some simple 
        //    business logic to return the results both via the dps back-end store
        //    as well as via this operator's output stream.
        //
        /*
        ================================================================================
        // In the code block below, we will execute most of the dps APIs to
        // demonstrate almost all possible dps operations.
        // These are all random tests with arbitrary <key, value> combinations.
        //
        // You can run the code block below and see the results
        // in this Java primitive operator's PE console log file. 
        ================================================================================        
        */
		// This dps API will return the NoSQL KV store product name that is configured by   
		// the user within the SPL project directory's etc/no-sql-kv-store-servers.cfg file.
        String dbProductName = sf.getNoSqlDbProductName();
        // Get the details about the machine where this operator is running.
        // This method returns a String array with 3 elements.
        // Each element will carry the value for machine name, os version, cpu architecture in that order.
        String [] machineDetails = new String[3];
        machineDetails = sf.getDetailsAboutThisMachine();
        // Display the NoSQL DB product name being used for this test run.
        System.out.println("=====================================================");
        System.out.println("Details about this DPS client machine:");
        System.out.println("NoSQL K/V store product name: " + dbProductName);
        System.out.println("Machine name: " + machineDetails[0]);
        System.out.println("OS version: " + machineDetails[1]);
        System.out.println("CPU architecture: " + machineDetails[2]);
        System.out.println("=====================================================");        
        
        // Before we start, a quick thing about how data will be stored in the back-end data store infrastructure.
        // There will be two kinds of storage areas available for the developers.
        //
        // 1) Global storage area where one can use a small subset of the dps APIs. 
        //    Data items stored here must have a TTL [Time To Live in seconds) property so that they will be
        //    automatically removed after the specified TTL time has expired. Certain applications will need such a 
        //    global storage space to keep the ephemeral Key Value pairs with a preset life time.
        //    
        // 2) Several user created stores that will act as containers to hold the data items forever unless
        //    otherwise the user deletes them or the user removes the entire store. Such user created stores support
        //    richer APIs than what one can do with the option (1) above. This type of user created stores will be the
        //    right way to use the dps facility, whereas the global storage area with the TTL feature can be used in
        //    special cases where there is a need to automatically age out the stored data items.
        // 
        // Let us first gain experience with option (1) which only supports 4 store activities [put, get, remove, has].
        // After learning option (1) i.e. global storage for TTL based K/V pairs, bulk of the remaining code will 
        // provide a detailed walk-through of all the possibilities for using option (2) i.e. user created stores.
        //
        // ================================= (1) put, get, remove, check existence of data items with TTL ====================================
        // In order to store TTL based key value pairs, one can directly start storing the data in the global storage area as shown below.
        // For the put operation with TTL option, very first argument is the key, second argument is the value, 
        // third argument is a non zero TTL in seconds, fourth argument is a string that tells the SPL type name of the key,
        // fifth argument is a string that tell the SPL type name of the value. Exception will be thrown if any error occurs 
        // during the chosen operation. Your key and value can be of any SPL type.
        // (If the TTL value is set to 0, then that K/V pair will not be removed automatically.
        //  Instead, it will stay there forever until the user calls the dpsRemoveTTL API to remove it.)    
        //
        // Do the TTL tests only on those back-end data store products that support the dps TTL APIs.
        if (dbProductName.equalsIgnoreCase("cloudant") == false) {
        	// DPS TTL APIs will let you assign arbitrary TTL values for individual K/V pairs when you use
        	// memcached, Redis, Cassandra, HBase, Mongo, or Couchbase. But, HBase doesn't allow different TTL values for different
        	// K/V pairs. HBase supports only a single TTL value for all the data items that are stored using
        	// the DPS TTL APIs. That is a limitation in HBase (as of Nov/2014). Hence, if you are using HBase,
        	// it is better to use the same TTL value for all your TTL based data items. If you change the TTL
        	// value across different dpsPutTTL calls, that will affect the expiration policy for the K/V pairs that
        	// were already stored. Please be aware of this HBase TTL behavior.        	
	        RString myKey = new RString(""), myValue = new RString("");
	        myKey = new RString("Harvard");
	        myValue = new RString("Cambridge");
	        
	        try {
	        	// Put a K/V pair with 5 seconds of TTL.  
	        	// We must provide the SPL type names for our key and value as literal strings as shown below.
	        	sf.putTTL(myKey, myValue, 5, "rstring", "rstring");
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Unexpected error in putTTL. Error code=" + sfe.getErrorCode() + ", Error msg=" + sfe.getErrorMessage());
	        }
	        
	        myKey = new RString("Yale");
	        myValue = new RString("New Haven");
	        boolean kvPairExists = false;
	        
	        try {
	        	sf.putTTL(myKey, myValue, 5, "rstring", "rstring");
	        } catch (StoreFactoryException sfe) {
	        	;
	        } 
	        
	        // Check for the existence of this key to ensure it is there in the global storage area of the back-end data store.
	        try {
	        	kvPairExists = sf.hasTTL(myKey, "rstring");
	        	
	        	if (kvPairExists == true) {
	        		System.out.println("TTL based K/V pair 'Yale':'New Haven' exists in the global store.");
	        	} else {
	        		System.out.println("TTL based K/V pair 'Yale':'New Haven' doesn't esist in the global store.");
	        	}
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Unexpected error in checking for the existence of the K/V pair 'Yale':'New Haven'. Error code=" + 
	        		sfe.getErrorCode() + ", Error msg=" + sfe.getErrorMessage());
	        } 
	        
	        // Read the value we stored in this TTL based data item.
	        myKey = new RString("Harvard");     
	        try {
	        	// You must provide the SPL type names for your key and value as literal strings. (2nd and 3rd arguments).
	        	myValue = (RString)sf.getTTL(myKey, "rstring", "rstring");
	        	System.out.println("TTL based K/V pair is read successfully from the global store. Key=" + myKey + ", Value=" + myValue);
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Unexpected error in reading the K/V pair 'Harvard':'Cambridge'. Error code=" + 
	            	sfe.getErrorCode() + ", Error msg=" + sfe.getErrorMessage());
	        }

            int delayInMilliSeconds = 7000;
            
            if (dbProductName.equalsIgnoreCase("mongo") == true) {
            	// In Mongo, its background TTL expiration task is launched only at every minute boundary (as of Dec/2014).
            	// Hence, we will wait for slightly more than a minute.
            	delayInMilliSeconds = 70000;
            }	        
	        
	        // Let use wait here for a few seconds so that those two data items will be removed automatically after the TTL expiration.
	        Thread.sleep(delayInMilliSeconds);
	        // If we try to read those two keys now, we should not see them in the back-end data store.
	        myKey = new RString("Yale");
	        myValue = new RString("");
	        
	        try {
	        	myValue = (RString)sf.getTTL(myKey, "rstring", "rstring");
	        	System.out.println("Unexpected error: TTL based K/V pair is still present after the TTL expiration. Key=" + myKey + ", Value=" + myValue);
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Expected error in reading the K/V pair 'Yale':'New Haven' after its TTL expiration. Error code=" + 
	        		sfe.getErrorCode() + ", Error msg=" + sfe.getErrorMessage());
	        }
	        
	        myKey = new RString("Harvard");
	        
	        try {
	        	kvPairExists = sf.hasTTL(myKey, "rstring");
	        	
	        	if (kvPairExists == true) {
	        		System.out.println("Unexpected error: TTL based K/V pair 'Harvard':'Cambridge' is still present after the TTL expiration.");
	        	} else {
	        		System.out.println("K/V pair 'Harvard':'Cambridge' was already removed after its TTL expiration.");
	        	}
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("K/V pair 'Harvard':'Cambridge' was already removed after its TTL expiration. Error code=" + 
	        		sfe.getErrorCode() + ", Error msg=" + sfe.getErrorMessage());
	        }
	        
	        // Let us exercise the remaining API (dpsRemoveTTL) that can be used with the TTL based data items.
	        // We can remove a TTL based data item ahead of its TTL expiration time.
	        // Let us use a complex typed key and value.
	        Map<String, Integer> myComplexKey = new HashMap<String, Integer>();     
	        myComplexKey.put("Apple", (int)1);
	        myComplexKey.put("Orange", (int)2);
	        // Following is the tuple type that was passed to this operator's process method above.
	        // Format: tuple<list<rstring> tickers>
	        Tuple myComplexValue = tuple; 
	
	        try {
	        	// 4th and 5th arguments are SPL type names for the key and value specified as literal strings.
	        	sf.putTTL(myComplexKey, myComplexValue, 5, "map<ustring,uint32>", "tuple<list<rstring> tickers>");
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Put1 error");
	        	;
	        }
	        
	        // Insert one more TTL based data item.
	        myComplexKey = new HashMap<String, Integer>(); 
	        myComplexKey.put("x", (int)23);
	        myComplexKey.put("y", (int)56);
	        
	        try {
	        	// 4th and 5th arguments are SPL type names for the key and value specified as literal strings.
	        	sf.putTTL(myComplexKey, myComplexValue, 5, "map<ustring,uint32>", "tuple<list<rstring> tickers>");
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Put2 error");
	        	;
	        }
	        
	        // Read back the data item we put earlier
	        myComplexKey = new HashMap<String, Integer>();     
	        myComplexKey.put("Apple", (int)1);
	        myComplexKey.put("Orange", (int)2);
	        
	        try {
	        	myComplexValue = null;
	        	myComplexValue = (Tuple)sf.getTTL(myComplexKey, "map<ustring,uint32>", "tuple<list<rstring> tickers>");
	        	System.out.println("TTL based K/V pair is read successfully from the global store. Key=" + myComplexKey + ", Value=" + myComplexValue);
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Unexpected error in reading the K/V pair for " + myComplexKey + ". Error code=" + 
	        		sfe.getErrorCode() + ", Error msg=" + sfe.getErrorMessage());
	        }
	        
	        // Let us remove the other complex data item we stored.
	        myComplexKey = new HashMap<String, Integer>(); 
	        myComplexKey.put("x", (int)23);
	        myComplexKey.put("y", (int)56);        
	        
	        try {
	        	sf.removeTTL(myComplexKey, "map<ustring,uint32>");
	        	System.out.println("Successfully removed the TTL based data item with a key " + myComplexKey + ".");
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("Unexpected error in removing the TTL based data item with a key " + 
	        		myComplexKey + ". Error code=" +  sfe.getErrorCode() + ", Error msg=" + sfe.getErrorMessage());
	        }
	        
	        // Let use wait here for a few seconds so that those two data items will be removed automatically after the TTL expiration.
	        Thread.sleep(delayInMilliSeconds);
	        // If we try to check for the existence of a data item now, we should not see it in the back-end data store.
	        myComplexKey = new HashMap<String, Integer>();     
	        myComplexKey.put("Apple", (int)1);
	        myComplexKey.put("Orange", (int)2);
	        
	        try {
	        	kvPairExists = sf.hasTTL(myComplexKey, "map<ustring,uint32>");
	        	
	        	if (kvPairExists == true) {
	        		System.out.println("Unexpected error: TTL based K/V pair for " + myComplexKey + " is still present after the TTL expiration.");
	        	} else {
	        		System.out.println("K/V pair for " + myComplexKey + " was already removed after its TTL expiration.");
	        	}
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("K/V pair existence check error for key=" + myComplexKey + ".");
	        }
	        

                // In this while loop, we are going to try the following 
                // new Redis specific features added in May/2017.
                // 1) A facility to store the key and/or the value as plain string (clear text) with
                //    no base64 encoding or Streams serialization.
                // 2) A facility to return the error code 102 (DPS_CONNECTION_ERROR) when the
                //    connection to the Redis server is broken in the middle of an application run.
                // 3) A new API to check the connection status to the Redis server. isConnected()
                // 4) A new API to reestablish connection to a Redis server. reconnect()
                //
                while(true) {
                   RString myNewKey = new RString(""), myNewValue = new RString("");
                   myNewKey = new RString("Key1");
                   myNewValue = new RString("Value1");
                   // Final two arguments are optional. First optional one to tell whether to
                   // encode the key or not. Second optional one to tell whether to
                   // serialize the value or not.
                   sf.putTTL(myNewKey, myNewValue, 60, "rstring", "rstring", false, false);
                   myNewKey = new RString("Key2");
                   myNewValue = new RString("Value2");
                   sf.putTTL(myNewKey, myNewValue, 60, "rstring", "rstring", false, false);

                   // A deliberate wait during which you can go stop the Redis server.
                   // Then, you will see in the PE logs that the following section of the code
                   // reporting that connection to Redis broken until you restart the Redis server.
                   // Once the Redis server is up, the following section of the code will
                   // reconnect and continue further.
                   Thread.sleep(10*1000);

                   try {
                      myNewKey = new RString("Key3");
                      myNewValue = new RString("Value3");
                      sf.putTTL(myNewKey, myNewValue, 60, "rstring", "rstring", false, false);
                      System.out.println("Successfully put Key3:Value3");
                      myNewKey = new RString("Key5");
                      // We can have a value in clear text with spaces in it.
                      myNewValue = new RString("Value5 with a space in it.");
                      sf.putTTL(myNewKey, myNewValue, 60, "rstring", "rstring", false, false);
                      myNewValue = new RString("");
                      myNewValue = (RString)sf.getTTL(myNewKey, "rstring", "rstring", false, false);
                      System.out.println("Test5-->myNewValue=" + myNewValue);
                      // We can have spaces in the clear text based key. 
                      // We can store a JSON formatted string as value with single/double quotes in it.
                      myNewKey = new RString("Key 55");
                      myNewValue = new RString("Value55 is a JSON: {'a': 456, 'b': 'hello world', 'c':456}");
                      // Let us get the actual stored size of the key and value in the back-end data store.
                      int[] storedKeyValueSize = new int[2];
                      sf.putTTL(myNewKey, myNewValue, 60, "rstring", "rstring", storedKeyValueSize, false, false);
                      System.out.println("storedKeySize=" + storedKeyValueSize[0] + ", storedValueSize=" + storedKeyValueSize[1]);
                      myNewValue = new RString("");
                      // Read the value from Redis as clear text.
                      myNewValue = (RString)sf.getTTL(myNewKey, "rstring", "rstring", false, false);
                      System.out.println("Test5b-->myNewValue=" + myNewValue);                      
                      break;
                   } catch (Exception ex) {
                      System.out.println("'" + myNewKey + "' with a value of '" + myNewValue + "' failed.");

                      // Check for connection failure with Redis.
                      if (sf.isConnected() == true) {
                         System.out.println("DPS connection is active. Ending the loop.");
                         break;
                      } else {
                         System.out.println("DPS connection went inactive. Attempting to reconnect.");

                         // DPS connection is inactive.
                         // Loop here until the connection is made.
                         int reconnectCnt = 0;
                         while(sf.reconnect() == false) {
                            System.out.println("DPS connection not reestablished. Trying again.");
                            reconnectCnt++;
                            if (reconnectCnt%4 == 0) {
                               System.out.println("Calling dpsHasTTL when reconnectCnt = " + reconnectCnt);
                               myNewKey = new RString("Key 55");
                               sf.hasTTL(myNewKey, "rstring", false);
                            }

                            Thread.sleep(5*1000);
                         }
                         
                         System.out.println("DPS reconnect successful. Going through the outer loop one more time.");
                         continue;
                      }
                   }
                } // End of while loop.

	        System.out.println("=== End of testing for TTL based put, get, has, and remove. ===");
        }
        // ==================== End of testing the features of global storage with TTL based data items =========================
        
        // ================================= (2) User created stores [Applicable in majority of the dps use cases) ===========================
        // As explained above, data items stored in the user created stores will live forever unless they are deleted by the user via an API.
        // Rest of the code below will feature everything that the user created stores support.
        // 1) Create a new store.
        Store store = null;
        try {
			// While creating a store, it is required to indicate which SPL type will make up the key and value of this store.
			// In the Java dps createStore APIs, you can simply pass a key type and a value type using the SPL syntax string as shown below.
        	// Doing that will enable their SPL types to be automatically inferred during the creation of that store.
        	// (e-g)  "rstring" (OR) "list<int32>" (OR) "map<float64, rstring>" (OR) "tuple<int32 x, rstring y>"
			// Important note: After creating a store this way, there will not be any check done during the future put operations to validate whether you are
			// using the correct data types indicated at the time of store creation via spl type syntax string. It is better to have all the
			// entries to have uniform key:value data types in order for that store to be practically useful. So, a simple advice is don't use
			// the put call with different data types for keys and values of any given store. If you do that, then you are on your own and
			// as a result you are making that store not very useful. It is left to the dps user to follow a disciplined approach for
			// maintaining content uniformity within a store. So, create a store with the required key and value types and simply stick to that
			// key:value pair data type for the full life of that store.
        	store = sf.createStore("Java Test Store1", "boolean", "boolean");
        	System.out.println("1) Created the Java Test Store1 with a storeId of " + store.getId());
        } catch (StoreFactoryException sfe) {
        	System.out.println("1) Unable to create the Java Test Store1. Error code = " + 
        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        	// Throw the same exception.
        	throw sfe;
        }
        
        // 2) Try creating a store that already exists.
        try {
        	store = sf.createStore("Java Test Store1", "boolean", "boolean");
        	System.out.println("2) Error: Created the Java Test Store1 with a storeId of " + store.getId()); 
        } catch (StoreFactoryException sfe) {
        	// We know this error will surely happen. Simply display the error and move on.
        	System.out.println("2) Expected error: Unable to create the Java Test Store1. Error code = " + 
            	sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        }

        // 3) Create a new store or get a store if it already exists.
        try {
        	store = sf.createOrGetStore("Java Test Store1", "boolean", "boolean");
        	System.out.println("3) Got the Java Test Store1 with a storeId of " + store.getId()); 
        } catch (StoreFactoryException sfe) {
        	System.out.println("3) Unable to get the Java Test Store1. Error code = " + 
        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        	// This error should not happen.
        	throw sfe;
        }

        // 4) Find an existing store.
        try {
        	store = sf.findStore("Java Test Store1");
        	System.out.println("4a) Found the Java Test Store1 with a storeId of " + store.getId());
        } catch (StoreFactoryException sfe) {
        	// We know this error will surely happen. Simply display the error and move on.
        	System.out.println("4a) Unable to find the Java Test Store1. Error code = " + 
            	sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        }        	

        // If you are given a store object, you can get the following metadata information about that store.
        // store name, key spl type name, value spl type name.
        System.out.println("4b) Metadata 1: We are working with a store named '" + store.getStoreName() + "'");
        System.out.println("4c) Metadata 2: The store we are working with has a key conforming to the SPL type '" + store.getKeySplTypeName() + "'");
        System.out.println("4d) Metadata 3: The store we are working with has a value conforming to the SPL type '" + store.getValueSplTypeName() + "'");
        
        // 5) Put data item into a store: <key, value> = <boolean, boolean>
        // First argument is your data item key that is made of any data type (supported by SPL)
        // Second argument is your data item value that is made of any data type (supported by SPL)
        // Please do a Google search for "Working with SPL Types".
        // In that Streams documentation section, you will see a table that tells you what Java object types are 
        // required for different kinds of SPL types. You have cast your data appropriately on the way into the
        // store and coming out of the store.
        try {
        	// Please be aware that there are two versions of the put operation.  (put and putSafe)
        	// End result is exactly the same in both of them.
        	// put is faster and putSafe is slower due to its overhead in performing many safety checks.
        	// You can choose between those two depending on your desire for speed.
        	///// store.putSafe(true, false);
        	store.put(true, false);
        	System.out.println("5a) Successfully put <boolean, boolean> data in the Java Test Store1 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("5a) Unable to put <boolean, boolean> in the Java Test Store1. Error code = " + 
            	se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <boolean, boolean>
        // First argument is your data item key that is made of any data type (supported by SPL)
        try {
        	boolean boolValue = (Boolean) store.get(true);
        	System.out.println("5b) dpsGet result for <boolean, boolean>: boolValue-->" + boolValue);
        } catch (StoreException se) {
        	System.out.println("5b) Unable to get <boolean, boolean>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // 6) Put data item into a store: <key, value> = <boolean, ustring>
        // We could keep adding different types of key:value pairs into the same store.
        // But, that will spoil the uniformity of the store contents, which is not a good practice and it is error prone.
        // Hence, we will recreate a new store with new key:value data types.        
        sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store6", "boolean", "ustring");
        try {
        	store.put(true, "Test this value");
        	// For this test, this line may display a negative store id in some back-end data stores (e-g: Cloudant. Don't be alarmed. It is because of a
        	// very large number getting displayed with overflow. Internal value of that long variable in Java is just fine. 
        	System.out.println("6a) Successfully put <boolean, ustring> data in the Java Test Store6 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("6a) Unable to put <boolean, ustring> in the Java Test Store6. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <boolean, ustring>
        try {
        	// Please be aware that there are two versions of the get operation.  (get and getSafe)
        	// End result is exactly the same in both of them.
        	// get is faster and getSafe is slower due to its overhead in performing many safety checks.
        	// You can choose between those two depending on your desire for speed.
        	///// String str = (String)store.getSafe(true);
        	String str = (String)store.get(true);
        	System.out.println("6b) dpsGet result for <boolean, ustring>: str-->" + str);
        } catch (StoreException se) {
        	System.out.println("6b) Unable to get <boolean, ustring>. Error code = " +  
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // 7) Put data item into a store: <key, value> = <rstring, float32>
        sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store7", "rstring", "float32");   
        RString yktString = new RString("Yorktown temperature reading");
        try {
        	store.put(yktString, 71.58f);
        	System.out.println("7a) Successfully put <rstring, float32> data in the Java Test Store7 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("7a) Unable to put <rstring, float32> in the Java Test Store7. Error code = " +  
            		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // Get data item from a store: <key, value> = <rstring, float32>
        try {
        	float temperature = (Float)store.get(yktString);
        	System.out.println("7b) dpsGet result for <rstring, float32>: temperature-->" + temperature);
        } catch (StoreException se) {
        	System.out.println("7b) Unable to get <rstring, float32>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }        
        
        // 8) Put data item into a store: <key, value> = <int16, int64>
        sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store8", "int16", "int64"); 
        try {
        	store.put((short)-32543, -10453249853L);
        	// For this test, this line may display a negative store id in some back-end data stores (e-g: Cloudant. Don't be alarmed. It is because of a
        	// very large number getting displayed with overflow. Internal value of that long variable in Java is just fine. 
        	System.out.println("8a) Successfully put <int16, int64> data in the Java Test Store8 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("8a) Unable to put <int16, int64> in the Java Test Store8. Error code = " + 
            		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // Get data item from a store: <key, value> = <int16, int64>
        try {
        	long negativeLongValue = (Long)store.get((short)-32543);
        	System.out.println("8b) dpsGet result for <int16, int64>: negativeLongValue-->" + negativeLongValue);
        } catch (StoreException se) {
        	System.out.println("8b) Unable to get <int16, int64>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 9) Put data item into a store: <key, value> = <uint32, uint64>
        sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store9", "uint32", "uint64");
        try {
        	store.put(1294967295, 8446744073709551615L);
        	System.out.println("9a) Successfully put <uint32, uint64> data in the Java Test Store9 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("9a) Unable to put <uint32, uint64> in the Java Test Store9. Error code = " + 
            	se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // Get data item from a store: <key, value> = <uint32, uint64>
        try {
        	long bigLongValue = (Long)store.get(1294967295);
        	System.out.println("9b) dpsGet result for <uint32, uint64>: bigLongValue-->" + bigLongValue);
        } catch (StoreException se) {
        	System.out.println("9b) Unable to get <uint32, uint64>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // 10) Put data item into a store: <key, value> = <timestamp, rstring>
        sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store10", "timestamp", "rstring");
        Timestamp delay = Timestamp.getTimestamp(TimeUnit.MILLISECONDS.toNanos(800L));
        RString predictionString = new RString("With smart hard work and with a little bit of LUCK, one can make several millions.");
        try {
        	store.put(delay, predictionString);
        	System.out.println("10a) Successfully put <timestamp, rstring> data in the Java Test Store10 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("10a) Unable to put <timestamp, rstring> in the Java Test Store10. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <timestamp, rstring>
        try {
        	RString futureState = (RString)store.get(delay);
        	System.out.println("10b) dpsGet result for <timestamp, rstring>: futureState-->" + futureState);
        } catch (StoreException se) {
        	System.out.println("10b) Unable to get <timestamp, rstring>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
  
        // 11) Put data item into a store: <key, value> = <int8, decimal128>
        sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store11", "int8", "decimal128");
        BigDecimal bd = new BigDecimal(0.1499999999999999944488848768742172978818416595458984375);
        try {
        	store.put((byte)-65, bd);
        	System.out.println("11a) Successfully put <int8, decimal128> data in the Java Test Store11 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("11a) Unable to put <int8, decimal128> in the Java Test Store11. Error code = " + 
            	se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <int8, decimal128>
        // You have to type cast the return value from dpsGet to the closest Java type that
        // corresponds to the stored value's SPL type.
        try {
        	BigDecimal newBigDec = (BigDecimal)store.get((byte)-65);
        	System.out.println("11b) dpsGet result for <int8, decimal128>: newBigDec-->" + newBigDec);
        } catch (StoreException se) {
        	System.out.println("11b) Unable to get <int8, decimal128>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 12) Put data item into a store: <key, value> = <ustring, complex64>
        sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store12", "ustring", "complex64");
        Complex complexNumber = new Complex(1.1111, 2.2222);
        String keyString = "Now is time for all good men and women to come to the aid of their nation.";
        try {
        	store.put(keyString, complexNumber);
        	System.out.println("12a) Successfully put <ustring, complex64> data in the Java Test Store12 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("12a) Unable to put <ustring, complex64> in the Java Test Store12. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <ustring, complex64>
        try {
        	Complex newComplexNumber = (Complex)store.get(keyString);
        	ComplexFormat format = new ComplexFormat();
        	System.out.println("12b) dpsGet result for <ustring, complex64>: newComplexNumber-->" + format.format(newComplexNumber));
        } catch (StoreException se) {
        	System.out.println("12b) Unable to get <ustring, complex64>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // IMPORTANT: Streams versions below 3.2 don't have a concrete implementation class for Blob.
        // They only have a Blob interface. Hence, we will come back and fix this after the 3.2 release in Nov/2013.
        // 13) Put data item into a store: <key, value> = <int32, blob>
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store13", "int32", "blob");
        int negativeInt32 = -2147483648;
        String testString = "The quick brown fox jumps over the lazy dog.";
        // Create a blob out of the above-mentioned test string.
        Blob payLoadBlob = ValueFactory.newBlob(testString.getBytes(Charset.forName("UTF-8")));
        
        try {
        	store.put(negativeInt32, payLoadBlob);
        	System.out.println("13a) Successfully put <int32, blob> data in the Java Test Store13 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("13a) Unable to put <int32, blob> in the Java Test Store13. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <int32, blob>
        try {
        	Blob retrievedBlob = (Blob)store.get(negativeInt32);
			// Let us convert the retrieved blob data to a String and see if we got back what we originally stored.
        	// ByteBuffer obtained from the Streams Blob object is read-only. If we access it directly,
        	// Java will throw java.nio.ReadOnlyBufferException. Hence, we have to make a copy of that buffer.
        	// In the Apr/2015 release of Streams, there will be a new method available: Blob.getData();
        	// At that time, replace the manual data copy done below.
        	ByteBuffer bb = retrievedBlob.getByteBuffer();
        	byte[] array = new byte[(int) retrievedBlob.getLength()];
        	// Get a copy of the original buffer contents into our array.
        	bb.get(array);
        	System.out.println("13b) dpsGet result for <int32, blob>: retrievedBlob-->" + 
        		new String(array, Charset.forName("UTF-8"))); 
        } catch (StoreException se) {
        	System.out.println("13b) Unable to get <int32, blob>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 14) Put data item into a store: <key, value> = <ustring, tuple>
        // Let us store the input tuple received by this Java primitive operator.
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store14", "ustring", "tuple<list<rstring> tickers>");
        keyString = "Stock ticker tuple";
        try {
        	store.put(keyString, tuple);
        	System.out.println("14a) Successfully put <ustring, tuple> data in the Java Test Store14 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("14a) Unable to put <ustring, tuple> in the Java Test Store14. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <ustring, tuple>
        try {
        	Tuple newTuple = (Tuple)store.get(keyString);
        	System.out.println("14b) dpsGet result for <ustring, tuple>: newTuple-->" + newTuple);
        } catch (StoreException se) {
        	System.out.println("14b) Unable to get <ustring, tuple>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }        
        
        // 15) Put data item into a store: <key, value> = <tuple, ustring>
        // This is the reverse of what we did in (14). Here, we will use tuple as the key and ustring as the value.
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store15", "tuple<list<rstring> tickers>", "ustring");
        keyString = "Stock ticker tuple";
        try {
        	store.put(tuple, keyString);
        	System.out.println("15a) Successfully put <tuple, ustring> data in the Java Test Store15 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("15a) Unable to put <tuple, ustring> in the Java Test Store15. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <tuple, ustring>
        try {
        	String tupleName = (String)store.get(tuple);
        	System.out.println("15b) dpsGet result for <tuple, ustring>: tupleName-->" + tupleName);
        } catch (StoreException se) {
        	System.out.println("15b) Unable to get <tuple, ustring>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }        

        // 16) Put data item into a store: <key, value> = <ustring, list<ustring>>
        // Helpful tip about using SPL collection types as a key or a value: 
        // Please read the Java primitive operator documentation (section: Working with SPL Types).
        // In that section, you will see a table that tells you what Java object types are required for different kinds of SPL lists.
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store16", "ustring", "list<ustring>");
        keyString = "Few U.S Presidents";
        String[] prezList = new String[4];
        prezList[0] = "Clinton";
        prezList[1] = "Bush";
        prezList[2] = "Nixon";
        prezList[3] = "Carter";
        try {
        	store.put(keyString, prezList);
        	System.out.println("16a) Successfully put <ustring, list<ustring>> data in the Java Test Store16 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("16a) Unable to put <ustring, list<ustring>> in the Java Test Store16. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <ustring, list<ustring>>
        try {
        	String[] newList = (String[])store.get(keyString);
        	System.out.println("16b) dpsGet result for <ustring, list<ustring>>: newList-->" + Arrays.toString(newList));
        } catch (StoreException se) {
        	System.out.println("16b) Unable to get <ustring, list<ustring>>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 17) Put data item into a store: <key, value> = <list<int16>, list<float32>>
        // Let us use SPL list types as both key and value.
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store17", "list<int16>", "list<float32>");
        short[] fahrenheitList= new short[5];
        fahrenheitList[0] = 78;
        fahrenheitList[1] = 57;
        fahrenheitList[2] = -18;
        fahrenheitList[3] = 27;
        fahrenheitList[4] = -32;
        
        float[] celsiusList = new float[5];
        celsiusList[0] = 25.5556f;
        celsiusList[1] = 13.8889f;
        celsiusList[2] = -27.7778f;
        celsiusList[3] = -2.77778f;
        celsiusList[4] = -35.5556f;
        try {
        	store.put(fahrenheitList, celsiusList);
        	System.out.println("17a) Successfully put <list<int16>, list<float32>> data in the Java Test Store17 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("17a) Unable to put <list<int16>, list<float32>> in the Java Test Store17. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <list<int16>, list<float32>>
        try {
        	float[] newCelsiusList = (float[])store.get(fahrenheitList);
        	System.out.println("17b) dpsGet result for <list<int16>, list<float32>>: newCelsiusList-->" + Arrays.toString(newCelsiusList));
        } catch (StoreException se) {
        	System.out.println("17b) Unable to get <list<int16>, list<float32>>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 18) Put data item into a store: <key, value> = <list<rstring>, list<int32>>
        // Let us use SPL list types as both key and value.
        // NOTE: In a previous test (16), we used list<ustring>. There, we defined that list as a direct Java String[] array.
        // We can't do that here for list<rstring>. Do a web search for "Working with SPL types" and in the resulting page 
        // look at the second table with SPL type Java object type mapping. You will see the following.
        // list<rstring> ----> java,util.List<RString>
        // Hence, we have to provide a Java List<RString> type.
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store18", "list<rstring>", "list<int32>");
        List<RString> randomRStringList = new ArrayList<RString>();
        randomRStringList.add(new RString("Joe"));
        randomRStringList.add(new RString("Mary"));
        randomRStringList.add(new RString("John"));
        randomRStringList.add(new RString("Kimberly"));
        randomRStringList.add(new RString("Mike"));
              
        int[] randomInt = new int[5];
        randomInt[0] = -45236;
        randomInt[1] = 256;
        randomInt[2] = -35;
        randomInt[3] = 65535;
        randomInt[4] = -453905;        
        try {
        	store.put(randomRStringList, randomInt);
        	System.out.println("18a) Successfully put <list<rstring>, list<int32>> data in the Java Test Store18 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("18a) Unable to put <list<rstring>, list<int32>> in the Java Test Store18. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <list<rstring>, list<int32>>
        try {
        	int[] newRandomInt = (int[])store.get(randomRStringList);
        	System.out.println("18b) dpsGet result for <list<rstring>, list<int32>>: newRandomInt-->" + Arrays.toString(newRandomInt));
        } catch (StoreException se) {
        	System.out.println("18b) Unable to get <list<rstring>, list<int32>>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 19) Put data item into a store: <key, value> = <list<int32>, <list<rstring>>
        // Let us do the exact reverse of (18)
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store19", "list<int32>", "list<rstring>");
        try {
        	store.put(randomInt, randomRStringList);
        	System.out.println("19a) Successfully put <list<int32>, <list<rstring>> data in the Java Test Store19 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("19a) Unable to put <list<int32>, <list<rstring>> in the Java Test Store19. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <list<rstring>, list<int32>>
        try {
        	List<RString> newRandomRStringList = (List<RString>)store.get(randomInt);
        	System.out.println("19b) dpsGet result for <list<int32>, <list<rstring>>: newRandomRStringList-->" + newRandomRStringList);
        } catch (StoreException se) {
        	System.out.println("19b) Unable to get <list<int32>, <list<rstring>>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 20) Put data item into a store: <key, value> = <set<float32>, set<rstring>>
        // Let us use SPL set types as both key and value. (Set has a nature of being unordered and not allowing duplicate elements)
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store20", "set<float32>", "set<rstring>");
        Set<Float> elevationData = new HashSet<Float>();
        elevationData.add(new Float(3.07));
        elevationData.add(new Float(19.69));
        elevationData.add(new Float(304.81));
        elevationData.add(new Float(102.64));
        elevationData.add(new Float(7726.32));
        
        Set<RString> cityNames = new HashSet<RString>();
        cityNames.add(new RString("Ankara"));
        cityNames.add(new RString("Chennai"));
        cityNames.add(new RString("New York"));
        cityNames.add(new RString("Melbourne"));
        cityNames.add(new RString("Addis Ababa"));
        
        try {
        	store.put(elevationData, cityNames);
        	System.out.println("20a) Successfully put <set<float32>, set<rstring>> data in the Java Test Store20 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("20a) Unable to put <set<float32>, set<rstring>> in the Java Test Store20. Error code = " +
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <set<float32>, set<rstring>>
        try {
        	Set<RString> newCityNames = (Set<RString>)store.get(elevationData);
        	System.out.println("20b) dpsGet result for <set<float32>, set<rstring>>: newCityNames-->" + newCityNames);
        } catch (StoreException se) {
        	System.out.println("20b) Unable to get <set<float32>, set<rstring>>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 21) Put data item into a store: <key, value> = <set<rstring>, set<float32>>
        // This is the exact reverse of what we did in (20).
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store21", "set<rstring>", "set<float32>");
        try {
        	store.put(cityNames, elevationData);
        	System.out.println("21a) Successfully put <set<rstring>, set<float32>> data in the Java Test Store21 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("21a) Unable to put <set<rstring>, set<float32>> in the Java Test Store21. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <set<rstring>, set<float32>>
        try {
        	Set<Float> newElevationData = (Set<Float>)store.get(cityNames);
        	System.out.println("21b) dpsGet result for <set<rstring>, set<float32>>: newElevationData-->" + newElevationData);
        } catch (StoreException se) {
        	System.out.println("21b) Unable to get <set<rstring>, set<float32>>. Error code = " +
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 22) Put data item into a store: <key, value> = <ustring, map<ustring, uint16>>
        // Let us use SPL map type as a value. 
		sf.removeStore(store);
		// A tip: There should not be any spaces when you have multiple tokens in a data type as in the "map<ustring,uint16>" below.
        store = sf.createOrGetStore("Java Test Store22", "ustring", "map<ustring,uint16>");
        String tempStr1 = "Favorite movies of everyone";
        
        Map<String, Short> favoriteMovies = new HashMap<String, Short>();     
        /*
        favoriteMovies.put(new String("The Sting"), new Short((short)1973));
        favoriteMovies.put(new String("It's a Wonderful Life"), new Short((short)1946));
        favoriteMovies.put(new String("E.T. the Extra-Terrestrial"), new Short((short)1982));
        favoriteMovies.put(new String("Star Wars: A New Hope"), new Short((short)1977));
        favoriteMovies.put(new String("The Lord of the Rings: The Fellowship of the Ring"), new Short((short)2001));
		*/
        favoriteMovies.put("The Sting", (short)1973);
        favoriteMovies.put("It's a Wonderful Life", (short)1946);
        favoriteMovies.put("E.T. the Extra-Terrestrial", (short)1982);
        favoriteMovies.put("Star Wars: A New Hope", (short)1977);
        favoriteMovies.put("The Lord of the Rings: The Fellowship of the Ring", (short)2001);
        
        try {
        	store.put(tempStr1, favoriteMovies);
        	System.out.println("22a) Successfully put <ustring, map<ustring,uint16>> data in the Java Test Store22 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("22a) Unable to put <ustring, map<ustring,uint16>> in the Java Test Store22. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <ustring, map<ustring, uint16>>
        try {
        	Map<String, Short> newFavoriteMovies = (Map<String, Short>)store.get(tempStr1);
        	System.out.println("22b) dpsGet result for <ustring, map<ustring,uint16>>: newFavoriteMovies-->" + newFavoriteMovies);
        } catch (StoreException se) {
        	System.out.println("22b) Unable to get <ustring, map<ustring,uint16>>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // If you are given a store object, you can get the following metadata information about that store.
        // store name, key spl type name, value spl type name.
        System.out.println("22c) Metadata 1: We are working with a store named '" + store.getStoreName() + "'");
        System.out.println("22d) Metadata 2: The store we are working with has a key conforming to the SPL type '" + store.getKeySplTypeName() + "'");
        System.out.println("22e) Metadata 3: The store we are working with has a value conforming to the SPL type '" + store.getValueSplTypeName() + "'");        
		sf.removeStore(store);
        store = sf.createOrGetStore("Java Test Store23", "map<ustring,uint16>", "ustring");		

		// IMPORTANT: As documented in the commentary at the very top of this file, memcached and Couchbase will not be able to handle 
    	// key lengths above 240 characters. After base64_encoding, this test case #23 will have a key size exceeding
    	// that limit. Hence, memcached and Couchbase servers will surely give an error. If you are using memcached or 
        // Couchbase, please comment out the entire block of code for test case #23 below. Test case #24 also depends on #23.
        // Hence comment out both #23 and #24 together in case of memcached and Couchbase.
        //
        // 23) Put data item into a store: <key, value> = <map<ustring,uint16>, ustring>
        // This is the exact reverse of what we did in (22).
		// A tip: There should not be any spaces when you have multiple tokens in a data type as in the "map<ustring,uint16>" below.
        try {
        	store.put(favoriteMovies, tempStr1);
        	System.out.println("23a) Successfully put <map<ustring,uint16>, ustring> data in the Java Test Store23 with a storeId of " + store.getId());
        } catch (StoreException se) {
        	System.out.println("23a) Unable to put <map<ustring,uint16>, ustring> in the Java Test Store23. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get data item from a store: <key, value> = <map<ustring,uint16>, ustring>
        try {
        	String newTempStr1 = (String)store.get(favoriteMovies);
        	System.out.println("23b) dpsGet result for <map<ustring,uint16>, ustring>: newTempStr1-->" + newTempStr1);
        } catch (StoreException se) {
        	System.out.println("23b) Unable to get <map<ustring,uint16>, ustring>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }

        // 24) Let us do three things together now.
        // We will do a data item existence check for an item that is surely there in the store, 
        // then we will remove that data item using its key, and then confirm it has been removed by
        // doing another data item existence check.
        // We are going to use the key and value we already prepared and stored in (18) above. 
        //
        // Check and remove a data item from a store: <key, value> = <map<ustring,uint16>, ustring>
        boolean keyFound = false;
        try {
        	keyFound = store.has(favoriteMovies);
        	System.out.println("24a) dpsHas result for <map<ustring,uint16>, ustring>: keyFound-->" + keyFound);
        } catch (StoreException se) {
        	System.out.println("24a) Unable to do dpsHas <map<ustring,uint16>, ustring>. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        if (keyFound == true) {
        	// This data item exists in the store.
        	// Let us remove it now.
        	boolean itemRemoved = false;
        	try {
        		itemRemoved = store.remove(favoriteMovies);
        		System.out.println("24b) dpsRemove result for <map<ustring,uint16>, ustring>: itemRemoved-->" + itemRemoved);
    			// Just for fun, let us do another existence check for the same data item key and confirm that it is completely gone from the store.
    			keyFound = store.has(favoriteMovies);
    			System.out.println("24c) dpsHas result for <map<ustring,uint16>, ustring>: keyFound-->" + keyFound);
    			
    			if (keyFound == false) {
    				System.out.println("24d) Data item with a key <map<ustring,uint16>, ustring> is no longer there in the store.");
    			}
        	} catch (StoreException se) {
        		System.out.println("24b) Unable to do dpsRemove <map<ustring,uint16>, ustring>. Error code = " + 
        			se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        	}
        		
        }

        // 25) Here, we are going to try two different dps APIs.
        // We will try to use both the clear and the size methods.
        // In order to test these two APIs, we need a store.
        // Let us create a new one quickly.
        Store testStore1 = null;
        try {
        	testStore1 = sf.createOrGetStore("A_Quick_Store", "int32", "ustring");
        	System.out.println("25a) Successfully created a new store named 'A_Quick_Store' with a store id " + 
        		testStore1.getId() + ".");
        } catch (StoreFactoryException sfe) {
        	System.out.println("25a) Unable to create a new store named 'A_Quick_Store': Error code = " +
        		sfe.getErrorCode() + ", Error msg = " + sfe.getErrorMessage());
        	// Rethrow the sane exception.
        	throw sfe;
        }
        
        // Let us add 7 random entries to this store.
        testStore1.put(1, "abc");
        testStore1.put(2, "def");
        testStore1.put(3, "ghi");
        testStore1.put(4, "jkl");
        testStore1.put(5, "mno");
        testStore1.put(6, "pqr");
        testStore1.put(7, "sto");
        
        // Let us get the size of this store now.
        long sizeOfTestStore1 = testStore1.size();
        System.out.println("25b) Size of testStore1 before clearing it = " + sizeOfTestStore1);
        // Let us empty this store now by removing all its contents in one fell swoop.
        testStore1.clear();
        // Confirm that this store is now empty.
        System.out.println("25c) Size of testStore1 after clearing it = " + testStore1.size());

        // 26) Let us try to get a non-existing data item from this store.
        try {
        	testStore1.get("MyKey");
        } catch (StoreException se) {
        	System.out.println("26a) Expected error: Unable to get 'MyKey' from a store named 'A_Quick_Store'. Error code = " + 
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // 27) Let us play with an important concept in our dps i.e. store iteration.
        // Store iteration must always be done in a sequence of three store operations. [Please adhere to that procedure.]
        // 1) StoreIterator it = storeObj.iterator(), 2) it.hasNext() in a while loop head, 3) it.next() in a while loop body
        // (OR) simply and more elegantly use a for loop on the store object to get the KeyValuePair objects.
        // In order for the store iteration to work, it is better to have a store with uniform contents. (i.e. uniform key and value types)
        // Let us add a few data items to the testStore1 which is currently empty now.
        // Since we are going to change the key data type from int32 to ustring, let us create a new store.
		sf.removeStore(testStore1);
    	testStore1 = sf.createOrGetStore("IBM CEO List", "ustring", "ustring");
        testStore1.put("1914–1956", "Thomas J. Watson");
        testStore1.put("1956–1971", "Thomas J. Watson, Jr");
        testStore1.put("1971–1973", "T. Vincent Learson");
        testStore1.put("1973–1981", "Frank T. Cary");
        testStore1.put("1981–1985", "John Opel");
        testStore1.put("1985–1993", "John F. Akers");
        testStore1.put("1993–2002", "Louis V. Gerstner, Jr.");
        testStore1.put("2002–2011", "Samuel J. Palmisano");
        testStore1.put("2012-XXXX", "Virginia M. Rometty");
        
        // Get an iterator for this store.
        StoreIterator it = testStore1.iterator();
        
        if (it != null) {
        	System.out.println("27a) Successfully obtained an iterator for testStore1.");
            // Stay in a loop, and iterate the store contents and display every data item as a key value pair.
            System.out.println("This is a prestigious CEO lineup of IBM in its illustrious history:");
            while (it.hasNext() == true) {
            	KeyValuePair kv = it.next();
            	// If a data item is successfully fetched during store iteration, then the key=>value can be
            	// obtained by two other getter methods on the key value pair object.
            	System.out.println("'" + kv.getKey() + "' => '" + kv.getValue() + "'");
            }
            
            System.out.println("27b) Successfully ended store iteration for testStore1.");
            
            // If we try to get the next data item after reaching the end of the iteration, it will throw an exception.
            // Let us test that.
            try {
            	it.next();
            } catch (java.util.NoSuchElementException nsee) {
            	System.out.println("27c) Expected error in executing next(). Error msg = " + nsee.getMessage());
            }
            
            // Optional task: Setting a store iterator object to null after the end of a store iteration is a 
            // very good practice to do an immediate cleanup of the iteration resources.
            it = null;
        } else {
        	System.out.println("27a) Unable to obtain an iterator for testStore1.");
        }
        
        System.out.println("27d) Another elegant way to iterate a store using a simple for loop:");
        
        for (KeyValuePair kv: testStore1) {
        	System.out.println("'" + kv.getKey() + "' => '" + kv.getValue() + "'");
        }
        
        sf.removeStore(testStore1);
        
        // 28) Let us serialize the entire store contents into a ByteBuffer.
        // We will create a new store.
        Store topBrandsStore = sf.createOrGetStore("2013_Best_Global_Brands_ABC", "int32", "ustring");
        // Add few data items.
        topBrandsStore.put(1, "Apple");
        topBrandsStore.put(2, "Google");
        topBrandsStore.put(3, "Coca Cola");
        topBrandsStore.put(4, "IBM");
        topBrandsStore.put(5, "Microsoft");
        topBrandsStore.put(6, "GE");
        topBrandsStore.put(7, "McDonald's");
        topBrandsStore.put(8, "Samsung");
        topBrandsStore.put(9, "Intel");
        topBrandsStore.put(10, "Toyota");

        // Serialize this entire store now.
        ByteBuffer serializedStore = null;
        try {
        	serializedStore = topBrandsStore.serialize();
        	System.out.println("28a) Successfully serialized the store '2013_Best_Global_Brands_ABC' = " + serializedStore);
        } catch (StoreException se) {
        	System.out.println("28a) Problem in serializing the store '2013_Best_Global_Brands_ABC'. Error code = " +
            	se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        	throw se;
        }

        // 29) Let us deserialize a byte buffer containing the serialized store contents. This action will populate a brand new store.
        // Remove the top brands store.
        sf.removeStore(topBrandsStore);
        // Set this store handle to null so that we can start from scratch.
        topBrandsStore = null;
        // Let us create a new store.
        topBrandsStore = sf.createOrGetStore("2013_Best_Global_Brands_XYZ", "int32", "ustring");
        System.out.println("29a) Size of the '2013_Best_Global_Brands_XYZ' store before deserialize: " + topBrandsStore.size());
        // We are going to populate this empty store by deserializing the serialized content into this new store.
        try {
        	topBrandsStore.deserialize(serializedStore);
        	System.out.println("29b) Successfully deserialized into the store '2013_Best_Global_Brands_XYZ'");
        } catch (StoreException se) {
        	System.out.println("29b) Problem in deserializing the byte buffer into the store '2013_Best_Global_Brands_XYZ'. Error code = " +
                se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
            throw se;        	
        }
        
        System.out.println("29c) Size of the '2013_Best_Global_Brands_XYZ' store after deserialize: " + topBrandsStore.size());
        // We can iterate the new store that was populated during byte buffer deserialization.
        System.out.println("29d) This is a list of top 10 rankings for the best global brands in 2013:");
        it = topBrandsStore.iterator();
        // When you iterate a store, there is no guarantee that you will get the entries in the same order in which they were originally added to the store.
        while (it.hasNext() == true) {
        	KeyValuePair kv = it.next();
        	// If a data item is successfully fetched during store iteration, then the key=>value can be
        	// obtained by two other getter methods on the key value pair object.
        	System.out.println("'" + kv.getKey() + "' => '" + kv.getValue() + "'");
        }

        // Again, why going through all that trouble to iterate a store?
        // Going forward, always use the following wonderful for loop approach.
        System.out.println("29e) The same 10 rankings listed below via a very simple for loop iteration:");
        for (KeyValuePair kv: topBrandsStore) {
        	System.out.println("'" + kv.getKey() + "' => '" + kv.getValue() + "'");
        }
        
        // We are done with testcase (28 and 29). Remove this store.
        sf.removeStore(topBrandsStore);
        
        // 30) Let us do a few experiments with the distributed locks.
        // If we want to do a bulk store operations in a transactional manner, it is advisable to
        // lock the store, perform a sequence of store operations, and then release the distributed lock.
        // This will ensure that multiple PEs are not stepping into each other while being at the same time inside a store.
        // Use of distributed locks require some planning while designing the Streams application components that will
        // create/update/delete data items in the same store.
        //
        // Create a distributed lock.
        Lock myLock = lf.createOrGetLock("Lock_For_Test_Store1");
        // Acquire that lock for a lease period of 30 seconds.
        try {
        	// First argument is the lease period for the lock.
        	// Second argument is the time in seconds we are willing to wait in order to acquire the lock.
        	// If a lock can't be acquired within that max wait time, then we will get a timeout exception.
        	myLock.acquireLock((double)30.0, (double)120.0);
        	System.out.println("30a) Successfully acquired the lock named 'Lock_For_Test_Store1'.");
        	// There is also a lock factory API to get the Linux PID of the current owner who is holding this lock.
        	int pid = lf.getPidForLock("Lock_For_Test_Store1");
        	System.out.println("30a) Linux PID for the current owner of the 'Lock_For_Test_Store1' = " + pid);
        } catch (LockException le) {
        	System.out.println("30a) Unable to acquire the lock named 'Lock_For_Test_Store1'. Error = " +
        		le.getErrorCode() + ", Error msg = " + le.getErrorMessage());
        	throw le;
        }
        
        testStore1 = sf.createOrGetStore("Store for distributed lock tests", "int32", "ustring");
        int loopCnt = 2000;
        
        if ((dbProductName.equalsIgnoreCase("cassandra") == true) || 
        	(dbProductName.equalsIgnoreCase("cloudant") == true) ||
        	(dbProductName.equalsIgnoreCase("hbase") == true) ||
        	(dbProductName.equalsIgnoreCase("couchbase") == true)) {
        	// Since Cassandra, Cloudant, HBase and Couchbase are slower than memcached, Redis and Mongo, let us reduce the bulk put count.
        	loopCnt = 100;
        }
        
        // We can be at peace now knowing that this store is fully locked and we are the only one inside at this time.
        // Let us do a bunch of store operations.
        for(int cnt = 1; cnt <= loopCnt; cnt++) {
        	testStore1.put(cnt, String.valueOf(cnt*10000)); 
        }

        // We are done with our bulk store operation.
        // We can release and remove this distributed lock.
        System.out.println("30b) Successfully performed a bulk insert in the store named 'A_Quick_Store'.");
        try {
        	myLock.releaseLock();
        	// In real life, locks will stay for the entire duration of a Streams application.
        	// Since, it is a simple example, we are removing this lock here.
        	lf.removeLock(myLock);
        	System.out.println("30c) Successfully released and removed the lock named 'Lock_For_Test_Store1'.");
        } catch (LockException le) {
        	System.out.println("30c) Unable to release/remove the lock named 'Lock_For_Test_Store1'. Error = " +
            		le.getErrorCode() + ", Error msg = " + le.getErrorMessage());
        	throw le;
        } catch (LockFactoryException lfe) {
        	System.out.println("30c) Unable to release/remove the lock named 'Lock_For_Test_Store1'. Error = " +
            		lfe.getErrorCode() + ", Error msg = " + lfe.getErrorMessage());
        	throw lfe;        	
        }
        // We are done with the testStore1. Remove it now.
        sf.removeStore(testStore1);
        
        // 31) Remove an existing store.
        try {
        	sf.removeStore(store);
        	System.out.println("31) Removed the store named " + store.getStoreName() + " with a storeId of " + store.getId());
        } catch(StoreFactoryException sfe) {
        	System.out.println("31) Unable to remove the store named " + store.getStoreName() + ". Error code = " + 
        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        	// Since the store definitely exists, this can't fail.
        	// Throw this same exception again.
        	throw sfe;
        }
        
        // 32) Try to find a store that is not there.
        try {
        	store = sf.findStore("Java Test Store1");
        	System.out.println("32) Found the Java Test Store1 with a storeId of " + store.getId());
        } catch (StoreFactoryException sfe) {
        	System.out.println("32) Expected error: Unable to find a non-existing Java Test Store1. Error code = " +
        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        	// This is error is normal. Proceed further.
        }

        // 33) Try to remove a store that is not there.
        try {
        	sf.removeStore(store);
        	System.out.println("33) Removed a store named " + store.getStoreName() + " with a storeId of " + store.getId());
        } catch(StoreFactoryException sfe) {
        	System.out.println("33) Expected error: Unable to remove a non-existing store named " + store.getStoreName() + ". Error code = " + 
        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        	// Since this store doesn't exist, this exception is okay. Proceed further.
        }

        // 34) Put a nested list into a store: <list<list<int32>>, list<list<int32>>>
        Store mnts = sf.createOrGetStore("My New Test Store", "list<list<int32>>", "list<list<int32>>");
        
        /*
        // This is one way to define an array of arrays.
        // But, our SPL NBF serialization will not work with this kind of
        // nested array definition using primitive types.
        // We can do a similar thing using ArrayList as shown below.
        // That is fully supported by our SPL NBF serialization.
        int[][] i1 = new int[3][];
        int[] tmp1 = new int[] {5, 7};
        i1[0] = tmp1;
        tmp1 = new int[] {45, 67, 28};
        i1[1] = tmp1;
        tmp1 = new int[] {87, 56, 72};
        i1[2] = tmp1;
 
        int[][] i2 = new int[3][];
        int[] tmp2 = new int[] {50434, 78222};
        i1[0] = tmp2;
        tmp2 = new int[] {45713, 67310, 28409};
        i1[1] = tmp2;
        tmp2 = new int[] {87182, 56629, 56629};
        i1[2] = tmp2;        
        */
 
        ArrayList<ArrayList<Integer>> i1 = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> tmp1 = new ArrayList<Integer>();
        tmp1.add(5);
        tmp1.add(7);
        i1.add(tmp1);
        tmp1 = new ArrayList<Integer>();
        tmp1.add(45);
        tmp1.add(67);
        tmp1.add(28);
        i1.add(tmp1);
        tmp1 = new ArrayList<Integer>();
        tmp1.add(87);
        tmp1.add(56);
        tmp1.add(72);
        tmp1.add(95);
        i1.add(tmp1);        

        ArrayList<ArrayList<Integer>> i2 = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> tmp2 = new ArrayList<Integer>();
        tmp2.add(50434);
        tmp2.add(78222);
        i2.add(tmp2);
        tmp2 = new ArrayList<Integer>();
        tmp2.add(45713);
        tmp2.add(67310);
        tmp2.add(28409);
        i2.add(tmp2);
        tmp2 = new ArrayList<Integer>();
        tmp2.add(87182);
        tmp2.add(56629);
        tmp2.add(72436);
        tmp2.add(95058);
        i2.add(tmp2);           

        try {
        	mnts.put(i1, i2);
        	System.out.println("34a) Successfully put <list<list<int32>>, list<list<int32>>> data in the 'My New Test Store' with a storeId of " + mnts.getId());
        } catch (StoreException se) {
        	System.out.println("34a) Unable to put <list<list<int32>>, list<list<int32>>> in the 'My New Test Store'. Error code = " +  
        		se.getErrorCode() + ", Error msg = " + se.getErrorMessage());
        }
        
        // Get a nested list from a store:  <list<list<int32>>, list<list<int32>>>
        System.out.println("34b) dpsGet result for <list<list<int32>>, list<list<int32>>>: " + mnts.get(i1));
        // Please note that we are not removing the "My New Test Store" here.
        // We will fetch the nested array value we put in this store later inside a downstream SPL Custom operator.
        // We will verify the result there and then remove this store in that operator.

        // 35) Run native commands directly on the chosen back-end data store.
		// If users want to execute simple arbitrary back-end data store (fire and forget)
		// native commands, this API can be used. This covers any Redis or Cassandra(CQL)
		// native commands that don't have to fetch and return K/V pairs or return size of the db etc.
		// (Insert and Delete are the more suitable ones here. However, key and value can only have string types.)
		// User must ensure that his/her command string is syntactically correct according to the
		// rules of the back-end data store you configured. DPS logic will not do the syntax checking.
        //
        // If Cloudant or HBase is used as a back-end data store, then dps supports two way commands to do a lot more
        // APIs in addition to the plain write and delete commands.
		//
		// We will simply take your command string and run it. So, be sure of what
		// command you are sending here.				
		//
        if (dbProductName.equalsIgnoreCase("redis") == true ||
    		dbProductName.equalsIgnoreCase("redis-cluster") == true) {
			// Let us try some simple Redis native commands (one way calls that don't fetch anything from the DB)
			// (You can't do get command using this technique. Similarly, no complex type keys or values.
			//  In that case, please use the regular dps APIs.)
			// 
			// Insert a K/V pair by using the popular Redis set command.        
	        String cmd = "set foo bar";
	        
	        try {
	        	sf.runDataStoreCommand(cmd);
	        	System.out.println("35a) Running a Redis native command 'set foo bar' worked correctly.");
				// Delete a K/V pair by using another Redis native command.
				cmd = "del foo";
				
				try {
					sf.runDataStoreCommand(cmd);
					System.out.println("35b) Running a Redis native command 'del foo' worked correctly.");
				} catch (StoreFactoryException sfe) {
		        	System.out.println("35b) Error in running a Redis native command 'del foo'. Error code=" + 
		            		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());				
				}
	        	
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("35a) Error in running a Redis native command 'set foo bar'. Error code=" + 
	        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
	        }

                // The following section of the code demonstrates how a new feature added
                // to the DPS toolkit in May/2017 lets you run any valid Redis command and
                // get the result back. This is much different from the one way (fire and forget)
                // runDataStore command you saw above. This new variation of the runDataStoreCommand
                // allows you to give any valid Redis command and get it executed on the 
                // Redis server along with returning the actual result from the Redis server.
                // If your keys and values are purely clear text based Stringsd, then you can do
                // a lot of Redis related work using this new API.
                List<RString> myCmdList = new ArrayList<RString>();
                String redisResult = "";
                   
                // Redis command: SETEX 'My Key 1' 60 'This is MyValue1 with some JSON. ..."
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.add(new RString("SETEX"));
                myCmdList.add(new RString("My Key 1"));
                myCmdList.add(new RString("60"));
                myCmdList.add(new RString("This is MyValue1 with some JSON. {'name':'John', 'age':30, 'cars':['Ford', 'BMW', 'Tesla']"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test1 [SETEX]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test1 [SETEX]-->runDataStoreCommand rc=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: GET 'My Key 1'
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("GET"));
                myCmdList.add(new RString("My Key 1"));
                
                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test2 [GET]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test2 [GET]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: DEL 'My Key 1'
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("DEL"));
                myCmdList.add(new RString("My Key 1"));
                   
                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test3 [DEL]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test3 [DEL]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: HMSET 'My wonderful hash' 'Field 1' 'Hello World' 'Field 2' 'Hello IBM' ...
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("HMSET"));
                myCmdList.add(new RString("My wonderful hash"));
                myCmdList.add(new RString("Field 1"));
                myCmdList.add(new RString("Hello World"));
                myCmdList.add(new RString("Field 2"));
                myCmdList.add(new RString("Hello IBM"));
                myCmdList.add(new RString("My JSON Field 3"));
                myCmdList.add(new RString("{'symbol':'IBM', 'price':157.45, 'quantity':284.327, 'order':'Buy'}"));
                myCmdList.add(new RString("Field 4"));
                myCmdList.add(new RString("Treat every single day as the best day ever."));
                   
                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test4 [HMSET]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test4 [HMSET]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: HMGET 'My wonderful hash' 'Field 1' 'My JSON Field 3'
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("HMGET"));
                myCmdList.add(new RString("My wonderful hash"));
                myCmdList.add(new RString("Field 1"));
                myCmdList.add(new RString("My JSON Field 3"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test5 [HMGET]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test5 [HMGET]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: HDEL 'My wonderful hash' 'Field 1'
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("HDEL"));
                myCmdList.add(new RString("My wonderful hash"));
                myCmdList.add(new RString("Field 1"));
                   
                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test6 [HDEL]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test6 [HDEL]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: HGETALL 'My wonderful hash'
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("HGETALL"));
                myCmdList.add(new RString("My wonderful hash"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test7 [HGETALL]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test7 [HGETALL]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: DEL 'My wonderful hash'
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("DEL"));
                myCmdList.add(new RString("My wonderful hash"));
                   
                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test8 [DEL hash]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test8 [DEL hash]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command with invalid hash name: HGET non-existing-hash field1
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("HGET"));
                myCmdList.add(new RString("non-existing-hash"));
                myCmdList.add(new RString("field1"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test9 [HGET with non-existing hash]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test9 [HGET with non-existing hash]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command with syntax error: SETXYZ field1 value1
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("SETXYZ"));
                myCmdList.add(new RString("field1"));
                myCmdList.add(new RString("value1"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test10 [SETXYZ]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test10 [SETXYZ]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: PING
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("PING"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test11 [PING]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test11 [PING]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: MSET one 1 two 2 three 3 four 4 'sixty two' 62 
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("MSET"));
                myCmdList.add(new RString("one"));
                myCmdList.add(new RString("1"));
                myCmdList.add(new RString("two"));
                myCmdList.add(new RString("2"));
                myCmdList.add(new RString("three"));
                myCmdList.add(new RString("3"));
                myCmdList.add(new RString("four"));
                myCmdList.add(new RString("4"));
                myCmdList.add(new RString("sixty two"));
                myCmdList.add(new RString("62"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test12 [MSET]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test12 [MSET]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: KEYS *o* 
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("KEYS"));
                myCmdList.add(new RString("*o*"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test13 [KEYS]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test13 [KEYS]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Redis command: DEL one two three four 'sixty two' 
                // From your Redis command, add the distinct parts into a List<RString>
                myCmdList.clear();
                redisResult = "";
                myCmdList.add(new RString("DEL"));
                myCmdList.add(new RString("one"));
                myCmdList.add(new RString("two"));
                myCmdList.add(new RString("three"));
                myCmdList.add(new RString("four"));
                myCmdList.add(new RString("sixty two"));

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test14 [DEL]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test14 [DEL]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }

                // Empty Redis command:  
                // From your Redis command, add the distinct parts into a list<rstring>
                myCmdList.clear();
                redisResult = "";

                try {
                   redisResult = sf.runDataStoreCommand(myCmdList);
                   System.out.println("Redis command Test15 [EMPTY cmd]-->runDataStoreCommand redisResult=" + redisResult);
                } catch (StoreFactoryException sfe) {
                   System.out.println("Redis command Test15 [EMPTY cmd]-->runDataStoreCommand redisResult=" + sfe.getErrorCode() + ", msg=" + sfe.getErrorMessage());
                }
        }
        
        if (dbProductName.equalsIgnoreCase("cassandra") == true) {
			// Let us try some simple Cassandra native commands (one way calls that don't fetch anything from the DB) 
			// (You can't do get command using this technique. Similarly, no complex type keys or values.
			//  In that case, please use the regular dps APIs.)
			// 
			// Create a keyspace by using a Cassandra CQL command.
        	String cmd = "create keyspace test_native_command_exec with replication = {'class' : 'SimpleStrategy', 'replication_factor' : 1};";
			
	        try {
	        	sf.runDataStoreCommand(cmd);
	        	System.out.println("35a) Running a Cassandra native command 'create keyspace test_native_command_exec;' worked correctly.");
	        	// Drop a keyspace using another Cassandra CQL command.
	        	cmd = "drop keyspace test_native_command_exec;";
				
				try {
					sf.runDataStoreCommand(cmd);
					System.out.println("35b) Running a Cassandra native command 'drop keyspace test_native_command_exec;' worked correctly.");
				} catch (StoreFactoryException sfe) {
		        	System.out.println("35b) Error in running a Cassandra native command 'drop keyspace test_native_command_exec;'. Error code=" + 
		            		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());				
				}
	        	
	        } catch (StoreFactoryException sfe) {
	        	System.out.println("35a) Error in running a Cassandra native command 'create keyspace test_native_command_exec;'. Error code=" + 
	        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
	        }
        }

        // We have a full fledged native command execution feature demonstration below for Cloudant.
        if (dbProductName.equalsIgnoreCase("cloudant") == true) {
			// For Cloudant, we will support two way commands since the request/response is done via JSON formatted strings.
			// That makes it easier to support almost all the Cloudant Database and Document based commands.
			// We will use the same dps API as used in Redis and Cassandra but with overloaded function arguments.
			// This overloaded API call will support all the HTTP verbs except COPY. So, you can use GET, PUT, POST, DELETE, and HEAD.
			// With those supported HTTP verbs, you can execute all the Cloudant HTTP REST APIs except for the APIs that involve attachments.
			// A very good reference for Cloudant HTTP REST/JSON APIs: https://docs.cloudant.com/api/index.html 
			//
			// DPS API format:
			// String runDataStoreCommand(int cmdType, String httpVerb, String baseUrl,
			//                            String apiEndpoint, String queryParams, 
			//                            String jsonRequest, long[] httpResponseCode) throws StoreFactoryException;
			//
			// This DPS API throws an exception when it encounters any error inside the DPS or in cURL calls before your command reaches the Cloudant server.
			// In the case of receiving an exception, you can get the error code and the error message from the StoreFactoryException object.
			// A return with no exception simply means that your HTTP REST API request was sent to the Cloudant server and a response was received from the server.
			// In that case, you will get the HTTP response code in the httpResponseCode method argument you passed. You should interpret the meaning of that HTTP code to 
			// know whether your request really succeeded or not. If the HTTP code indicates "all went well", then the String returned by this API will contain the
			// JSON response string as returned by the Cloudant server for the API you performed.
			//
			// cmdType: Should be 1 if you are executing any of the Cloudant database related APIs.
			//          Should be 2 if you are executing any of the Cloudant document related APIs.
			//
			// httpVerb: Should be one of the supported HTTP verbs (GET, PUT, POST, DELETE, HEAD). [COPY is not a supported verb in this DPS API.]
			// 
			// baseUrl: For the public cloud based Cloudant service, it must be in this format:
			//             http://user:password@user.cloudant.com
			//          For the "Cloudant Local" on-premises infrastructure, it must be in this format: 
			//             http://user:password@XXXXX where XXXXX is a name or IP address of your on-premises "Cloudant Local" load balancer machine.
			//          NOTE: If you give an empty string for the URL, then the Cloudant server configured
			//                in the SPL project directory's etc/no-sql-kv-store-servers.cfg file will be used.
			// 
			// apiEndPoint: It should be a Cloudant DB or document related portion of the URL path as documented in the Cloudant APIs.
			//
			// queryParams: It should be in this format: name1=value1&name2=value2&name3=value3
			//
			// jsonRequest: This is your JSON request needed by the Cloudant API you are executing. Please ensure that any special
			//              characters such as double quotes are properly escaped using the backslash character.     
			//
			// httpResponseCode:  [It should be an an array of long with a size of 1.]
			//      If this DPS API doesn't throw an exception, then this argument will be set to the HTTP response code returned by the Cloudant server.
			//      You have to interpret the meaning of the returned HTTP response code and make your further logic from there. 
			//
			// Your input arguments given above will form the full URL inside this API: <baseUrl>/<API endpoint path>?<queryParams> 
			//						
			// If everything worked with no errors, a String returned by this API brings back any JSON response string received from
			// the Cloudant server while executing your HTTP REST request. 
			// ========================= CLOUDANT DB LEVEL REQUESTS ARE SHOWN BELOW =========================
			System.out.println("=== Start of the native data store command execution for the Cloudant DB level requests ===");
			// 35a) Let us create a new database: PUT /db
			// We are going to make a database related HTTP request.
			// For the public cloud based Cloudant service, it must be in this format:
			// http://user:password@user.cloudant.com
			// For the "Cloudant Local" on-premises infrastructure, it must be in this format: 
			// http://user:password@XXXXX where XXXXX is a name or IP address of your on-premises "Cloudant Local" load balancer machine.
			//
			// NOTE: If you give an empty string for the URL, then the Cloudant server configured
			// in the SPL project directory's etc/no-sql-kv-store-servers.cfg file will be used.
			String baseUrl = ""; 
			long[] httpResponseCode = new long[1];
			int cmdType = 1;
			String httpVerb = "PUT";
			// Specify your new database name.
			// An API endpoint URL path must always begin with a forward slash character.
			String apiEndpoint = "/my_db_1";      
			String queryParams = "";
			String jsonRequest = "";
			httpResponseCode[0] = 0;
			String jsonResponse = "";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 202 || httpResponseCode[0] == 412) {
					System.out.println("35a) Cloudant database creation: " + apiEndpoint + 
						" is now available for use. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35a) Cloudant database " + apiEndpoint + 
						" was not created. Error code = " + sfe.getErrorCode() +
						". Error msg = " + sfe.getErrorMessage());				
			}

			// 35b) Let us create a second database: PUT /db
			apiEndpoint = "/my_db_2";
			jsonRequest = "";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 202 || httpResponseCode[0] == 412) {
					System.out.println("35b) Cloudant database creation: " + apiEndpoint + 
						" is now available for use. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35b) Cloudant database " + apiEndpoint + 
						" was not created. Error code = " + sfe.getErrorCode() +
						". Error msg = " + sfe.getErrorMessage());				
			}

			// 35c) Let us create a third database: PUT /db
			apiEndpoint = "/my_db_3";
			jsonRequest = "";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 202 || httpResponseCode[0] == 412) {
					System.out.println("35c) Cloudant database creation: " + apiEndpoint + 
						" is now available for use. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35c) Cloudant database " + apiEndpoint + 
					" was not created. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// 35d) Let us get a list of all databases: GET /_all_dbs
			httpVerb = "GET"; 
			apiEndpoint = "/_all_dbs";
			jsonRequest = "";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35d) List of the cloudant databases " + apiEndpoint + 
						" was obtained. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35d) List of the cloudant databases " + apiEndpoint + 
					" could not be obtained. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}

			// 35e) Let us get the db information: GET /db
			apiEndpoint = "/my_db_1";
			jsonRequest = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35e) DB information " + apiEndpoint + 
					" was obtained. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35e) DB information " + apiEndpoint + 
					" could not be obtained. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}			
			
			// 35f) Let us delete a database now: DELETE /db
			httpVerb = "DELETE";
			apiEndpoint = "/my_db_2";
			jsonRequest = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35f) DB deletion " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35f) DB deletion " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}			

			// 35g) Let us delete a database now: DELETE /db
			httpVerb = "DELETE";
			apiEndpoint = "/my_db_3";
			jsonRequest = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35g) DB deletion " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35g) DB deletion " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}			

			// 35h) Let us insert documents in bulk: POST /db/_bulk_docs
			httpVerb = "POST";
			apiEndpoint = "/my_db_1/_bulk_docs";
			// All the double quotes in your JSON request must be escaped via a backslash character.
			jsonRequest = "{\"docs\": [" +
				"{\"_id\": \"IBM\", \"HQ\": \"Armonk, NY\", \"Date Founded\": \"June 16, 1911\", \"First CEO\": \"Thomas J. Watson\"}," +
				"{\"_id\": \"Microsoft\", \"HQ\": \"Redmond, WA\", \"Date Founded\": \"April 4, 1975\", \"First CEO\": \"Bill Gates\"}," +
				"{\"_id\": \"Amazon\", \"HQ\": \"Seattle, WA\", \"Date Founded\": \"July 5, 1994\", \"First CEO\": \"Jeff Bezos\"}," +
				"{\"_id\": \"Google\", \"HQ\": \"Mountain View, CA\", \"Date Founded\": \"September 4, 1998\", \"First CEO\": \"Larry Page\"}]}";		  

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201) {
					System.out.println("35h) Insert documents in bulk " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35h) Insert documents in bulk " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}			
			
			// 35i) Let us retrieve all documents in bulk: GET /db/_all_docs
			httpVerb = "GET";
			apiEndpoint = "/my_db_1/_all_docs";
			jsonRequest = "";
			queryParams = "descending=true&include_docs=true&limit=10";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				System.out.println("35i) Retrieve all documents in bulk " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
			} catch (StoreFactoryException sfe) {
				System.out.println("35i) Retrieve all documents in bulk " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}			

			// 35j) Let us retrieve selective documents in bulk: POST /db/_all_docs
			httpVerb = "POST";
			apiEndpoint = "/my_db_1/_all_docs";
			jsonRequest = "{\"keys\": [\"IBM\", \"Amazon\", \"Google\"]}";
			queryParams = "include_docs=true&limit=10";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				System.out.println("35j) Retrieve selective documents in bulk " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
			} catch (StoreFactoryException sfe) {
				System.out.println("35j) Retrieve selective documents in bulk " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}				
			
			// 35k) Let us retrieve information about shards in a DB: GET /db/_shards
			httpVerb = "GET";
			apiEndpoint = "/my_db_1/_shards";
			jsonRequest = "";
			queryParams = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				System.out.println("35k) Retrieve information about shards in a DB " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
			} catch (StoreFactoryException sfe) {
				System.out.println("35k) Retrieve information about shards in a DB " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}

			// 35l) Let us delete a database now: DELETE /db
			httpVerb = "DELETE";
			apiEndpoint = "/my_db_1";
			jsonRequest = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35l) DB deletion " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35l) DB deletion " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());	
			}			
			
			// ...
			// ...
			// If you are interested, you can add code for the remaining Cloudant DB level API requests here.
			// ...
			// ...
			System.out.println("=== End of the native data store command execution for the Cloudant DB level requests ===");
			// ========================= CLOUDANT DOC LEVEL REQUESTS ARE SHOWN BELOW =========================				
			System.out.println("");								
			System.out.println("=== Start of the native data store command execution for the Cloudant DOC level requests ===");
			// 35m) Let us create a fourth database: PUT /db
			cmdType = 1;
			httpVerb = "PUT";
			apiEndpoint = "/my_db_4";
			jsonRequest = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 202 || httpResponseCode[0] == 412) {
					System.out.println("35m) Cloudant database creation: " + apiEndpoint + 
						" is now available for use. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35m) Cloudant database " + apiEndpoint + 
					" was not created. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			

			// 35n) Let us insert a new document now: POST /db
			cmdType = 2;
			httpVerb = "POST";
			apiEndpoint = "/my_db_4";
			jsonRequest = 
				"{\"_id\": \"Yankees\", \"Home\": \"Bronx, NY\", \"Championships\": 27, " + 
				  "\"A Few Legends\": [\"Babe Ruth\", \"Lou Gehrig\", \"Joe DiMaggio\", \"Mickey Mantle\", \"Derek Jeter\"]}";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201) {
					System.out.println("35n) Cloudant document creation " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35n) Cloudant document " + apiEndpoint + 
					" was not created. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			

			// 35o) Let us insert a new document now using a different technique: PUT /db/doc
			httpVerb = "PUT";
			// Only the API endpoint needs to be taken care for entity characters such as space, ampersand etc. Not the JSON request string.
			apiEndpoint = "/my_db_4/Red%20Sox";
			jsonRequest = 
				"{\"_id\": \"Red Sox\", \"Home\": \"Boston, MA\", \"Championships\": 8, " + 
				  "\"A Few Legends\": [\"Ted Williams\", \"Carl Yastrzemski\", \"Cy Young\", \"Johnny Pesky\"]}";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 202) {
					System.out.println("35o) Cloudant document creation " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35o) Cloudant document " + apiEndpoint + 
					" was not created. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			

			// 35p) Let us retrieve a document from a given database: GET db/doc
			httpVerb = "GET";
			apiEndpoint = "/my_db_4/Yankees";
			jsonRequest = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35p) Retrieve a document from DB " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35p) Retrieve a document from DB " + apiEndpoint + 
					" was not completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}

			// Save it for use later in the code below for showing how to perform the document update.
			String yankeesDoc = jsonResponse;			
			
			// 35q) Let us retrieve a document from a given database: GET db/doc
			apiEndpoint = "/my_db_4/Red%20Sox";
			jsonRequest = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35q) Retrieve a document from DB " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35q) Retrieve a document from DB " + apiEndpoint + 
					" was not completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// Save it for use later in the code below for showing how to perform the document deletion.
			String redSoxDoc = jsonResponse;

			// 35r, 35s) Let us update an existing document: PUT db/doc
			// Get the revision number from the previously retrieved json response.
			// Ideally, we should be parsing it using a good JSON API.
			// Instead of that, we are going to do string parsing for our layman exercise here.
			// In the json document that was retrieved earlier, we should have a _rev element as shown below.
			// "_rev": "1-2b458b0705e3007bce80b0499a1199e7"
			// Let us skip two double quote characters from the beginning of the _rev tag to 
			// get to the actual revision number of the document we want to update.
			boolean revisionNumberFound = false;
			int idx1 = yankeesDoc.indexOf("_rev\":", 0);
			if (idx1 != -1) {
				// Let us get the first of two double quote characters.
				idx1 = yankeesDoc.indexOf("\"", idx1);
				
				if (idx1 != -1) {
					// Let us get the second double quote character.
					idx1 = yankeesDoc.indexOf("\"", idx1+1);
					
					if (idx1 != -1) {
						// Now, let us get the double quote that appears at the end of the revision number.
						int idx2 = yankeesDoc.indexOf("\"", idx1+1);
					
						if (idx2 != -1) {
							// We now have everything to parse the revision number
							// (Please forgive for not using a JSON API which would have made it a lot simpler.)
							String revisionNumber = yankeesDoc.substring(idx1+1, idx2);
							revisionNumberFound = true;
							// In order to update an existing document, we must add a _rev tag in our JSON reqeust and
							// assign it to the revision number we parsed above.
							httpVerb = "PUT";
							apiEndpoint = "/my_db_4/Yankees";
							jsonRequest = 
								"{\"_id\": \"Yankees\", \"Home\": \"Bronx, NY\", \"Championships\": 27, " + 
							  	"\"A Few Legends\": [\"Babe Ruth\", \"Lou Gehrig\", \"Joe DiMaggio\", \"Yogi Berra\", \"Mickey Mantle\", \"Derek Jeter\"], " + 
							  	"\"_rev\": \"" + revisionNumber + "\"}";

							try {
								jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
								if (httpResponseCode[0] == 201) {
									System.out.println("35r) Cloudant document update " + apiEndpoint + 
									" was completed. JSON response = " + jsonResponse);
								}
							} catch (StoreFactoryException sfe) {
								System.out.println("35r) Cloudant document update " + apiEndpoint + 
									" was not completed. Error code = " + sfe.getErrorCode() +
									". Error msg = " + sfe.getErrorMessage());				
							}
						}
					}
				}
			}
			
			if (revisionNumberFound == false) {
				System.out.println("35r) Unable to parse the revision number of the Cloudant document. Hence, update document operation was aborted.");
			} else {
				// 35s) Let us retrieve a document from a given database: GET db/doc
				httpVerb = "GET";
				apiEndpoint = "/my_db_4/Yankees";
				jsonRequest = "";

				try {
					jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
					if (httpResponseCode[0] == 200) {
						System.out.println("35s) Retrieve a document from DB " + apiEndpoint + 
						" was completed. JSON response = " + jsonResponse);
					}
				} catch (StoreFactoryException sfe) {
					System.out.println("35s) Retrieve a document from DB " + apiEndpoint + 
						" was not completed. Error code = " + sfe.getErrorCode() +
						". Error msg = " + sfe.getErrorMessage());				
				}				
			}			

			// 35t) Let us delete an existing document: DELETE db/doc 
			// Get the revision number from the previously retrieved json response.
			// Ideally, we should be parsing it using a good JSON API.
			// Instead of that, we are going to do string parsing for our layman exercise here.
			// In the json document that was retrieved earlier, we should have a _rev element as shown below.
			// "_rev": "1-2b458b0705e3007bce80b0499a1199e7"
			// Let us skip two double quote characters from the beginning of the _rev tag to 
			// get to the actual revision number of the document we want to update.
			revisionNumberFound = false;
			idx1 = redSoxDoc.indexOf("_rev\":", 0);
			if (idx1 != -1) {
				// Let us get the first of two double quote characters.
				idx1 = redSoxDoc.indexOf("\"", idx1);
				
				if (idx1 != -1) {
					// Let us get the second double quote character.
					idx1 = redSoxDoc.indexOf("\"", idx1+1);
					
					if (idx1 != -1) {
						// Now, let us get the double quote that appears at the end of the revision number.
						int idx2 = redSoxDoc.indexOf("\"", idx1+1);
					
						if (idx2 != -1) {
							// We now have everything to parse the revision number
							// (Please forgive for not using a JSON API which would have made it a lot simpler.)
							String revisionNumber = redSoxDoc.substring(idx1+1, idx2);
							revisionNumberFound = true;
							// In order to delete an existing document, we must add a rev query param and 
							// assign it to the revision number we parsed above.
							httpVerb = "DELETE";
							apiEndpoint = "/my_db_4/Red%20Sox";
							jsonRequest = "";
							queryParams = "rev=" + revisionNumber; 								

							try {
								jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
								if (httpResponseCode[0] != 409) {
									System.out.println("35t) Cloudant document deletion " + apiEndpoint + 
									" was completed. JSON response = " + jsonResponse);
								}
							} catch (StoreFactoryException sfe) {
								System.out.println("35t) Cloudant document deletion " + apiEndpoint + 
									" was not completed. Error code = " + sfe.getErrorCode() +
									". Error msg = " + sfe.getErrorMessage());				
							}							
						}
					}
				}
			}
			
			if (revisionNumberFound == false) {
				System.out.println("35t) Unable to parse the revision number of the Cloudant document. Hence, delete document operation was aborted.");
			}			

			// 35u) Let us try a different technique to get the revision number and size of a document: HEAD /db/doc
			httpVerb = "HEAD";
			apiEndpoint = "/my_db_4/Yankees";
			jsonRequest = "";
			queryParams = "";								

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35u) Obtain revision and size of a document " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35u) Obtain revision and size of a document " + apiEndpoint + 
					" was not completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// 35v) Let us delete a database now: DELETE /db
			cmdType = 1;
			httpVerb = "DELETE";
			apiEndpoint = "/my_db_4";
			jsonRequest = "";
			queryParams = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("35v) DB deletion " + apiEndpoint + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35v) DB deletion " + apiEndpoint + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			System.out.println("=== End of the native data store command execution for the Cloudant DOC level requests ===");
			// Please note that the runDataStoreCommand API can be used only in Redis, Cassandra, Cloudant, and HBase. (As of Dec/2014).
		} // End of if (dbProductName == "cloudant")


		// We have a full fledged native command execution feature demonstration below for HBase.
		if (dbProductName.equalsIgnoreCase("hbase") == true) {
			// For HBase, we will support two way commands since the request/response is done via JSON formatted strings.
			// That makes it easier to support many of the HBase data store native commands.
			// We will use the same dps API as used in Redis and Cassandra but with overloaded function arguments.
			// This overloaded API call will support these HTTP verbs: GET, PUT, POST, DELETE, and HEAD.
			// With those supported HTTP verbs, you can execute the HTTP REST APIs necessary to do the HBase CRUD operations.
			// Some good references for the HBase HTTP REST/JSON APIs:
			// http://wiki.apache.org/hadoop/Hbase/Stargate
			// https://cwiki.apache.org/confluence/display/KNOX/Examples+HBase
			//
			// DPS API format:
			// boolean dpsRunDataStoreCommand(uint32 cmdType, rstring httpVerb, rstring baseUrl,
			//                                rstring apiEndpoint, rstring queryParams, rstring jsonRequest,
			//                                mutable rstring jsonResponse, mutable uint64 err);
			//
			// This DPS API returns false when it encounters any error inside the DPS or in cURL calls before your command reaches the HBase server.
			// In the case of a false return value, you can get the error code from the err argument (See the explanation for err below.)
			// A return value of true simply means that your HTTP REST API request was sent to the HBase server and a response was received from the server.
			// In that case, you will get the HTTP response code in the err argument and you should interpret the meaning of that HTTP code to 
			// know whether your request really succeeded or not. 
			//
			// cmdType: This is not necessary when you use HBase. You can simply set it to 0.
			//
			// httpVerb: Should be one of the supported HTTP verbs (GET, PUT, POST, DELETE, HEAD).
			// 
			// baseUrl: It must be in this format:
			//             http://user:password@HBase-REST-ServerNameOrIPAddress:port
			//          Note: If you give an empty string for the URL, then the HBase server(s) configured
			//                in the SPL project directory's etc/no-sql-kv-store-servers.cfg file will be used.
			// 
			// apiEndPoint: It should be the resource portion of the URL path as documented in the HBase REST APIs.
			//
			// queryParams: You may need to set queryParams for scanner APIs. In other cases, you can set it to an empty string.
			//
			// jsonRequest: This is your JSON request needed by the HBase API you are executing. Please ensure that any special
			//              characters such as double quotes are properly escaped using the backslash character.     
			//
			// jsonResponse: This is one of the two mutable variables you must pass to this DPS API.
			//               This argument brings back any JSON response string received from the HBase server while executing your HTTP REST request.
			//
			// err: 
			//      If this DPS API returns false, then this mutable argument will be set to any DPS or cURL errors that occurred inside the DPS code.
			//      To receive more details about the DPS or cURL errors, you can call the dpsGetLastStoreErrorString() DPS API. 
			//      If this DPS API returns true, then this argument will be set to the HTTP response code returned by the HBase server.
			//      In case of this API returning true, there will not be any additional error or status messages provided. You have to
			//      interpret the meaning of the returned HTTP response code and make your further logic from there. 
			//
			// Your input arguments given above will form the full URL inside this API: <baseUrl>/<API endpoint path> 
			//						
			// ========================= HBASE REST REQUESTS ARE SHOWN BELOW =========================
			System.out.println("=== Start of the native data store command execution for HBase ===");
			// 35a) Let us create a new table: PUT /TableName/schema
			// We are going to make a HTTP request related to table creation.
			String baseUrl = ""; 
			long[] httpResponseCode = new long[1];
			int cmdType = 0;
			String httpVerb = "PUT";
			// Specify your new table name.
			// An API endpoint URL path must always begin with a forward slash character.
			// Similarly, in the apiEndpoint you should substitute these special characters with their encoded values:
			// Space --> "%20"
			// "+" --> "%2B"
			// "/" --> "%2F"
			String apiEndpoint = "/my_table_1/schema";
			String queryParams = "";
			String jsonRequest = "{\"name\": \"my_table_1\", " + 
					"\"ColumnSchema\": [{\"name\": \"cf1\", \"VERSIONS\": \"1\", \"IN_MEMORY\": \"TRUE\"}, " +
	                                   "{\"name\": \"cf2\", \"VERSIONS\": \"1\", \"IN_MEMORY\": \"TRUE\"}, " +
	                                   "{\"name\": \"cf3\", \"VERSIONS\": \"1\", \"IN_MEMORY\": \"TRUE\"}]}";
			httpResponseCode[0] = 0;
			String jsonResponse = "";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 200) {
					System.out.println("35a) HBase table creation: my_table_1" + 
					" is now available for use. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35a) HBase table my_table_1" + 
						" was not created. Error code = " + sfe.getErrorCode() +
						". Error msg = " + sfe.getErrorMessage());				
			}

			// 35b) Let us create a second table: PUT /TableName/schema
			apiEndpoint = "/my_table_2/schema";
			jsonRequest = "{\"name\": \"my_table_2\", " + 
				"\"ColumnSchema\": [{\"name\": \"cf1\", \"VERSIONS\": \"1\", \"IN_MEMORY\": \"TRUE\"}]}";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 200) {
					System.out.println("35b) HBase table creation: my_table_2" + 
					" is now available for use. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35b) HBase table my_table_2" + 
						" was not created. Error code = " + sfe.getErrorCode() +
						". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// 35c) Let us create a third table: PUT /TableName/schema			
			apiEndpoint = "/my_table_3/schema";
			jsonRequest = "{\"name\": \"my_table_3\", " + 
				"\"ColumnSchema\": [{\"name\": \"cf1\", \"VERSIONS\": \"1\", \"IN_MEMORY\": \"TRUE\"}]}";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 201 || httpResponseCode[0] == 200) {
					System.out.println("35c) HBase table creation: my_table_3" + 
					" is now available for use. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("35c) HBase table my_table_3" + 
						" was not created. Error code = " + sfe.getErrorCode() +
						". Error msg = " + sfe.getErrorMessage());				
			}			

			// 36) Let us get a list of all the tables: GET /
			httpVerb = "GET"; 
			apiEndpoint = "/";
			jsonRequest = "";
			jsonResponse = "";			

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("36) List of the HBase tables " + 
					" was obtained. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("36) List of the HBase tables" + 
					" could not be obtained. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// 37) Let us get the table information: GET /TableName/schema
			apiEndpoint = "/my_table_2/schema";
			jsonRequest = "";
			jsonResponse = "";			

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("37) Table information for my_table_2" + 
					" was obtained. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("37) Table information for my_table_2" + 
					" could not be obtained. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// 38a) Let us delete a table now: DELETE /TableName/schema
			httpVerb = "DELETE";
			apiEndpoint = "/my_table_2/schema";
			jsonRequest = "";
			jsonResponse = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("38a) Table deletion of my_table_2" + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("38a) Table deletion of my_table_2" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}				
			
			// 38b) Let us delete a table now: DELETE /TableName/schema
			httpVerb = "DELETE";
			apiEndpoint = "/my_table_3/schema";
			jsonRequest = "";
			jsonResponse = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("38b) Table deletion of my_table_2" + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("38b) Table deletion of my_table_2" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}	

			// 39) Let us insert multiple rows into a table: PUT /TableName/DummyRowKeyName
			//
			// In the HBase row insertion REST API, we must give the HBase table name and a
			// dummy Row key name. Actual row key name will be sent via the JSON request string.
			// Hence, having a dummy row name (e-g: RowData) in the URL resource path is not an issue at all.
			httpVerb = "PUT";
			apiEndpoint = "/my_table_1/RowData";
			// All the double quotes in your JSON request must be escaped via a backslash character.
			// In a sing JSON request, we can pack as many rows as we want to insert.
			// In this test, we are going to insert 4 different rows in our HBase table.
			// In the HBase REST APIs, all the "ColumnFamily:ColumnQualifier" and the corresponding
			// "Cell value" must be base64 encoded. There are base64 encode/decode APIs available in our DPS.
	        String[] rk = new String[5], cn = new String[5], hq = new String[5], df = new String[5], fc = new String[5];
			// Base64 encoded value will be filled inside the mutable string variable passed via the 2nd argument.						
			// HBase row key
			rk[0] = sf.base64Encode("1");
			rk[1] = sf.base64Encode("2");
			rk[2] = sf.base64Encode("3");
			rk[3] = sf.base64Encode("4");
	        
			// HBase column key (Format: ColumnFamily:ColumnQualifier]
			cn[0] = sf.base64Encode("cf1:Company");
			// HBase column value
			cn[1] = sf.base64Encode("IBM");
			cn[2] = sf.base64Encode("Microsoft");
			cn[3] = sf.base64Encode("Amazon");
			cn[4] = sf.base64Encode("Google");			
	        
			hq[0] = sf.base64Encode("cf1:HQ");
			hq[1] = sf.base64Encode("Armonk, NY");
			hq[2] = sf.base64Encode("Redmond, WA");
			hq[3] = sf.base64Encode("Seattle, WA");
			hq[4] = sf.base64Encode("Mountain View, CA");			

			df[0] = sf.base64Encode("cf1:Date Founded");
			df[1] = sf.base64Encode("June 16, 1911");
			df[2] = sf.base64Encode("April 4, 1975");
			df[3] = sf.base64Encode("July 5, 1994");
			df[4] = sf.base64Encode("September 4, 1998");			

			fc[0] = sf.base64Encode("cf1:First CEO");
			fc[1] = sf.base64Encode("Thomas J. Watson");
			fc[2] = sf.base64Encode("Bill Gates");
			fc[3] = sf.base64Encode("Jeff Bezos");
			fc[4] = sf.base64Encode("Larry Page");			
			
			// HBase put K/V pair REST API JSON request format:
			// {"Row":[{"key":"X","Cell":[{"column":"A","$":"a"}]},{"key":"Y","Cell":[{"column":"B","$":"dGVzdA=="}]}]}
			jsonRequest = 
				"{\"Row\":[" +
					"{\"key\":\"" + rk[0] + "\"," +
						"\"Cell\":[" +
							"{\"column\":\"" + cn[0] + "\",\"$\":\"" + cn[1] + "\"}," +
							"{\"column\":\"" + hq[0] + "\",\"$\":\"" + hq[1] + "\"}," +
							"{\"column\":\"" + df[0] + "\",\"$\":\"" + df[1] + "\"}," +
							"{\"column\":\"" + fc[0] + "\",\"$\":\"" + fc[1] + "\"}]}," +
					"{\"key\":\"" + rk[1] + "\"," +
						"\"Cell\":[" +
							"{\"column\":\"" + cn[0] + "\",\"$\":\"" + cn[2] + "\"}," +
							"{\"column\":\"" + hq[0] + "\",\"$\":\"" + hq[2] + "\"}," +
							"{\"column\":\"" + df[0] + "\",\"$\":\"" + df[2] + "\"}," +
							"{\"column\":\"" + fc[0] + "\",\"$\":\"" + fc[2] + "\"}]}," +
					"{\"key\":\"" + rk[2] + "\"," +
						"\"Cell\":[" +
							"{\"column\":\"" + cn[0] + "\",\"$\":\"" + cn[3] + "\"}," +
							"{\"column\":\"" + hq[0] + "\",\"$\":\"" + hq[3] + "\"}," +
							"{\"column\":\"" + df[0] + "\",\"$\":\"" + df[3] + "\"}," +
							"{\"column\":\"" + fc[0] + "\",\"$\":\"" + fc[3] + "\"}]}," +
					"{\"key\":\"" + rk[3] + "\"," +
						"\"Cell\":[" +
							"{\"column\":\"" + cn[0] + "\",\"$\":\"" + cn[4] + "\"}," +
							"{\"column\":\"" + hq[0] + "\",\"$\":\"" + hq[4] + "\"}," +
							"{\"column\":\"" + df[0] + "\",\"$\":\"" + df[4] + "\"}," +
							"{\"column\":\"" + fc[0] + "\",\"$\":\"" + fc[4] + "\"}]}]}";
							
			jsonResponse = "";	
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("39) Insertion of multiple rows in my_table_1" + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("39) Insertion of multiple rows in my_table_1" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// 40) Let us retrieve all the rows from a table: GET /TableName/*
			httpVerb = "GET";
			apiEndpoint = "/my_table_1/*";
			jsonRequest = "";
			jsonResponse = "";
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("40) Retrieve all rows from my_table_1" + 
						" was completed. JSON response = ");
					displayHBaseTableRows(jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("40) Retrieve all rows from my_table_1" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}						

			// 41) Let us retrieve all columns in a specific row: GET /TableName/RowKey
			httpVerb = "GET";
			apiEndpoint = "/my_table_1/1";
			jsonRequest = "";
			jsonResponse = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("41) Retrieve all columns from row '1' of my_table_1" + 
						" was completed. JSON response = ");
					displayHBaseTableRows(jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("41) Retrieve all columns from row '1' of my_table_1" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
												
			// 42) Let us retrieve a specific column family in a specific row: GET /TableName/RowKey/ColumnFamily
			httpVerb = "GET";
			apiEndpoint = "/my_table_1/4/cf1";
			jsonRequest = "";
			jsonResponse = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("42) Retrieve a specific column family 'cf1' from row '4' of my_table_1" + 
						" was completed. JSON response = ");
					displayHBaseTableRows(jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("42) Retrieve a specific column family 'cf1' from row '4' of my_table_1" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			
			
			// 43) Let us retrieve a specific column qualifier in a specific row: GET /TableName/RowKey/ColumnFamily:ColumnQualifier
			httpVerb = "GET";
			apiEndpoint = "/my_table_1/3/cf1:Company";
			jsonRequest = "";
			jsonResponse = "";				

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("43) Retrieve a specific column qualifier 'cf1:Company' from row '3' of my_table_1" + 
						" was completed. JSON response = ");
					displayHBaseTableRows(jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("43) Retrieve a specific column qualifier 'cf1:Company' from row '3' of my_table_1" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}
			
			// 44) Let us get meta data information about an HBase table: GET /TableName/regions
			httpVerb = "GET";
			apiEndpoint = "/my_table_1/regions";
			jsonRequest = "";
			jsonResponse = "";	
			
			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("44) Get meta data information about my_table_1" + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("44) Get meta data information about my_table_1" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}			

			// 38c) Let us delete a table now: DELETE /TableName/schema
			httpVerb = "DELETE";
			apiEndpoint = "/my_table_1/schema";
			jsonRequest = "";
			jsonResponse = "";

			try {
				jsonResponse = sf.runDataStoreCommand(cmdType, httpVerb, baseUrl, apiEndpoint, queryParams, jsonRequest, httpResponseCode);
				if (httpResponseCode[0] == 200) {
					System.out.println("38c) Table deletion of my_table_1" + 
					" was completed. JSON response = " + jsonResponse);
				}
			} catch (StoreFactoryException sfe) {
				System.out.println("38c) Table deletion of my_table_1" + 
					" could not be completed. Error code = " + sfe.getErrorCode() +
					". Error msg = " + sfe.getErrorMessage());				
			}
		
			// ...
			// ...
			// Important REST APIs for CRUD functions were already covered above.
			// If you are interested, you can add code for more HBase table actions via REST calls.
			// You can try these:
			// Try to update a cell value in a specific column [You can do a similar logic shown in step(39) above.]
			// Try to delete a specific row [You can do a similar logic shown in step(38c). But, with an apiEndpoint of "/TableName/RowKey"
			// Try to delete a specific column family. [You can do a similar logic shown in step(38c). But, with an apiEndpoint of "/TableName/RowKey/ColumnFamily"
			// Try to delete a specific column. [You can do a similar logic shown in step(38c). But, with an apiEndpoint of "/TableName/RowKey/ColumnFamily:ColumnQualifier"
			// ...
			// ...
			System.out.println("=== End of the native data store command execution for HBase ===");
			// Please note that the dpsRunDataStoreCommand API can be used only in Redis, Cassandra, Cloudant, and HBase. (As of Dec/2014).
		} // End of if (dbProductName == "hbase")        
        
        // ===============================================================================
		// So far, we used this Java primitive operator as an excuse to give you a grand tour of
		// the various possibilities in the dps toolkit. We have not forgotten the real
		// business logic that needs to be performed by this operator.
        // In this code block, we are going to do exactly that.
        // What is the simple business logic being performed here?
        // This primitive operator will pull out the "ticker symbol and the company name" from Thing1_Store ONLY for
        // those ticker symbols sent in the stock picks list as an input tuple attribute.
        // BTW: Thing1_Store was created by a separate PE i.e. an SPL Custom operator.
        // Then, it will create a unique ticker id for every ticker symbol specified in the stock picks list and insert 
        // "ticker symbol => unique ticker id" in a new store called "Thing2_Store".
        Store t1s = null;
        try {
        	// First method argument is your store name.
        	t1s = sf.findStore("Thing1_Store");
        } catch (StoreFactoryException sfe) {
        	// Unable to get the store.
        	System.out.println("Unable to get the Thing1_Store: Error code = " + 
        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        	// Throw the same exception.
        	throw sfe;
        }

        // Print the metadata entries for the t1s store.
        System.out.println("t1s metadata 1: We are working with a store named '" + t1s.getStoreName() + "'");
        System.out.println("t1s metadata 2: The store we are working with has a key conforming to the SPL type '" + t1s.getKeySplTypeName() + "'");
        System.out.println("t1s metadata 3: The store we are working with has a value conforming to the SPL type '" + t1s.getValueSplTypeName() + "'");
        
        Store t2s = null;
        // Let us create a brand new store called "Thing2_Store".
        try {
        	t2s = sf.createOrGetStore("Thing2_Store", "rstring", "uint64");
        } catch (StoreFactoryException sfe) {
        	// Unable to create a new store.
        	System.out.println("Unable to create the Thing2_Store: Error code = " + 
        		sfe.getErrorCode() + ", Error Msg = " + sfe.getErrorMessage());
        	// Throw the same exception.
        	throw sfe;
        }
        
        // Get the stock picks list sent by the upstream operator via our input tuple.
        List<?> list1 = (List<?>)tuple.getList("tickers");
        int listSize = list1.size();
        // Now loop through the stock picks list.
        for (int cnt = 0; cnt < listSize; cnt++) {
        	RString tickerSymbol = (RString)list1.get(cnt);
        	// Look up the company name for a given ticker symbol from the "Thing1_Store".
        	RString companyName = null;
        	try {
        		companyName = (RString)t1s.get(tickerSymbol);
        	} catch (StoreException se) {
        		String msg = "TickerIdGenerator: Unable to get the company name from Thing1_Store for ticker symbol " + 
        			tickerSymbol + ". Error code = " + se.getErrorCode() + ", Error Msg = " + se.getErrorMessage();
        		System.out.println(msg);
        		// Rethrow the same exception.
        		throw se;
        	}
        	
        	// Let us compute a unique hash code for this company name.
        	long tickerId = (long)companyName.hashCode();
        	// Put this away in the Thing2_Store now.
        	try {
        		t2s.put(tickerSymbol, tickerId);
        	} catch (StoreException se) {
        		String msg = "TickerIdGenerator: Unable to put the tickerId " + tickerId + 
    				" for the ticker symbol " + tickerSymbol + " in the Thing2_Store. Error code = " + 
    				se.getErrorCode() + ", Error Msg = " + se.getErrorMessage();
        		System.out.println(msg);
        		throw se;
        	}
        }
        
        // We finished creating a new Thing2_Store and created/inserted "TickerSymbol => TickerId" entries in it.
        // Let us send something on this primitive operator's output tuple.
        // Set any value to this attribute.
        outTuple.setInt("dummy", 77);
        // Submit new tuple to output port 0
        // Send this dummy tuple away to a downstream operator to indicate ticker ids were generated successfully.
        outStream.submit(outTuple);  
        // We are done with the simple business logic we set out for this Java primitive operator.
        // Rest of the logic in this primitive operator is all about learning more about the
        // capabilities of the dps (Distributed Process Store). We will do that by exercising
        // several APIs available in our dps.
        // ===============================================================================        
    }
    
    /**
     * Process an incoming punctuation that arrived on the specified port.
     * @param stream Port the punctuation is arriving on.
     * @param mark The punctuation mark
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public void processPunctuation(StreamingInput<Tuple> stream,
    		Punctuation mark) throws Exception {
    	// For window markers, punctuate all output ports 
    	super.processPunctuation(stream, mark);
    }

    /**
     * Shutdown this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.

        // Must call super.shutdown()
        super.shutdown();
    }
    
    // This method provides an utility function for parsing and displaying the JSON results received while
    // executing the native HBase put/get commands in the process method above.
    public void displayHBaseTableRows(String jsonResponse) {
    	// You should properly parse it using a JSON library.
    	// i.e. via your own C++ or Java native functions that can parse JSON in the right way. 
    	// But, as a quick and dirty solution, we are going to use string token 
    	// parsing to pull out the K/V pairs from this JSON result message.
    	// Response will be in this format:
    	// {"Row":[{"key":"X","Cell":[{"column":"A","timestamp":1,"$":"a"}]},{"key":"Y","Cell":[{"column":"B","timestamp":1,"$":"b"}]}]}
    	//
    	int rowIdx1 = 0, rowIdx2 = 0, keyIdx1 = 0, keyIdx2 = 0, valueIdx1 = 0, valueIdx2 = 0;
    	while(true) {
    		// Find the next row.
    		rowIdx1 = jsonResponse.indexOf("{\"key\":", rowIdx2);
    		if (rowIdx1 == -1) {
    			// Row not found.
    			break;
    		} 
    		
    		// Parse the row key name.
    		String rowKey = "";
    		String base64DecodedString = "";
    		String columnKey = "";
    		String columnValue = "";
    		// Find the beginning of the row key name.
    		rowIdx1 = jsonResponse.indexOf(":\"", rowIdx1);
    		if (rowIdx1 == -1) {
    			break;
    		}
    		
    		// Find the end of the row key name.
    		rowIdx2 = jsonResponse.indexOf("\",", rowIdx1);
    		if (rowIdx2 == -1) {
    			break;
    		}
    		
    		// Parse the row key name
    		rowKey = jsonResponse.substring(rowIdx1+2, rowIdx2);
    		try {
    			base64DecodedString = sf.base64Decode(rowKey);
    		} catch (StoreFactoryException sfe) {
    			;
    		}
    		System.out.print(base64DecodedString + "-->");
    		boolean firstColumnKeyFound = false;
    		
    		// We got our row key. Let us now collect all the K/V pairs stored in this row.
    		while(true) {
    			// Locate the key field.
    			keyIdx1 = jsonResponse.indexOf("column\":\"", keyIdx2);
    			if (keyIdx1 == -1) {
    				break;
    			}
    			
    			// Find the end of the key field.
    			keyIdx2 = jsonResponse.indexOf("\",", keyIdx1);
    			if (rowIdx2 == -1) {
    				break;
    			}
    			
    			// Parse the column key name.
    			columnKey = jsonResponse.substring(keyIdx1+9, keyIdx2);
    			try {
    				base64DecodedString = sf.base64Decode(columnKey);
    			} catch (StoreFactoryException sfe) {
    				;
    			}
    			// If there are more than one K/V pair, then dispaly them with comma to separate them.
    			if (firstColumnKeyFound == true) {
    				System.out.print(", ");
    			}
    			// Decoded column key will have the "cf1:" prefix. Let us not display that prefix.
    			System.out.print(base64DecodedString.substring(4) + ":");
    			firstColumnKeyFound = true;
    			
    			// Locate the value field.
    			valueIdx1 = jsonResponse.indexOf("$\":\"", valueIdx2);
    			if (valueIdx1 == -1) {
    				break;
    			}
    			
    			// Find the end of the value field.
    			valueIdx2 = jsonResponse.indexOf("\"}", valueIdx1);
    			if (valueIdx2 == -1) {
    				break;
    			}
    			
    			// Parse the column value name.
    			columnValue = jsonResponse.substring(valueIdx1+4, valueIdx2);
    			try {
    				base64DecodedString = sf.base64Decode(columnValue);
    			} catch (StoreFactoryException sfe) {
    				;
    			}
    			System.out.print(base64DecodedString);
    			
    			// If there are no more K/V pairs beyond this, let us skip this loop.
    			if (jsonResponse.charAt(valueIdx2+2) == ']') {
    				System.out.println("");
    				break;
    			}
    		}
    	} 
    }    
}
